left_join(modules_host %>% dplyr::select(host_ID,host_group), by = "host_ID")
return(dat)
}
# function for calculating NMI between the host's group and the host's grid and calculating p value for the value
fun_nmi_calc <- function(dat, figure) {
# input: dat = ASV data in long format, figure = print the figure? (T/F)
# output: data frame with observed NMI value and p value, if figure=T a figure of shuffled nmi distribution
hosts <- dat %>% distinct(host_ID, grid, host_group)
nmi_obs <- aricode::NMI(hosts$grid, hosts$host_group)
nmi_shuff <- vector(length = 1000)
for(i in 1:1000) {
# shuffling the grid attribute
hosts_shuff <- hosts %>%
mutate(grid = sample(grid,nrow(hosts)))
# calculating nmi
nmi_shuff[i] <- aricode::NMI(hosts_shuff$grid, hosts_shuff$host_group)
}
# calculating p value
p <- length(nmi_shuff[nmi_shuff>nmi_obs]) / length(nmi_shuff)
# plotting
if(figure){
g <- as.data.frame(nmi_shuff) %>%
ggplot(aes(nmi_shuff)) +
geom_histogram() +
theme_bw() +
geom_vline(xintercept = nmi_obs, linetype='dashed', color="red") +
theme(axis.text = element_text(size = 14, color = 'black'), title = element_text(size = 20)) +
labs(x="NMI", y="No. of Shuffled Networks")
} else {
g <- NULL
}
nmi_summary <- tibble(nmi = nmi_obs,
p = p)
return(list(nmi_summary, g))
}
# calculating NMI for different values of core microbiome
# core microbiome = the number of hosts the asv infects (asv's degree)
fun_modularity_diff_core <- function(dat, nmi_observed, cor_seq) {
#####
# running for core microbiome
nmi_summary_core <- NULL
for (i in core_seq) {
# filtering out ASVs with lower degree than the threshold
data_asv_filtered_core <- dat %>% filter(asv_degree >= i)
# modularity
modules <- fun_modularity_analysis(data_asv_filtered_core)
# NMI
nmi_mid <- fun_nmi_calc(modules, FALSE)
nmi_mid <- nmi_mid[[1]] %>%
mutate(degree = i, type = "core", sig = ifelse(p <= 0.05, 1, 0))
nmi_summary_core <- rbind(nmi_summary_core, nmi_mid)
}
#####
# running for non-core microbiome
nmi_summary_noncore <- NULL
for (j in core_seq) {
# filtering out ASVs with lower degree than the threshold
data_asv_filtered_noncore <- dat %>% filter(asv_degree <= j)
# modularity
modules <- fun_modularity_analysis(data_asv_filtered_noncore)
# NMI
nmi_mid <- fun_nmi_calc(modules, FALSE)
nmi_mid <- nmi_mid[[1]] %>%
mutate(degree = j, type = "non-core", sig = ifelse(p <= 0.05, 1, 0))
nmi_summary_noncore <- rbind(nmi_summary_noncore, nmi_mid)
}
#####
# plotting the results
#nmi_summary <- rbind(nmi_summary_core, nmi_summary_noncore)
p1 <- nmi_summary_core %>%
ggplot(aes(x=degree, y=nmi)) +
geom_point(color = "blue") +
geom_line(color = "blue") +
geom_hline(yintercept = nmi_observed[[1]]$nmi, linetype = "dashed") +
scale_y_continuous(limits = c(0, 0.35)) +
scale_x_continuous(limits = c(0, 15)) +
theme_bw() +
theme(axis.text = element_text(size = 12, color = 'black'), title = element_text(size = 14), legend.position = "none", plot.title = element_text(hjust = 0.5)) +
labs(title = "Core Microbes", x="Minimum ASVs Degree", y="Normalized Mutual Information (NMI)")
p2 <- nmi_summary_noncore %>%
ggplot(aes(x=degree, y=nmi)) +
geom_point(color = "red") +
geom_line(color="red") +
geom_hline(yintercept = nmi_observed[[1]]$nmi, linetype = "dashed") +
scale_y_continuous(limits = c(0, 0.35)) +
scale_x_continuous(limits = c(0, 15)) +
theme_bw() +
theme(axis.text = element_text(size = 12, color = 'black'), title = element_text(size = 14), legend.position = "none",plot.title = element_text(hjust = 0.5)) +
labs(title = "Non-Core Microbes", x="Maximum ASVs Degree", y="Normalized Mutual Information (NMI)")
p3 <- cowplot::plot_grid(p1,p2)
final_figs <- list(p3)
return(final_figs)
}
# function for calculating similarity in modules between grids
fun_modules_similarity <- function(dat) {
# matrix of grid similarity in modules
grid_modules <- dat %>%
group_by(grid, host_group) %>%
summarise(host_n = n_distinct(host_ID)) %>%
spread(host_group, host_n, fill = 0) %>%
mutate(grid = as.character(grid)) %>%
arrange(grid) %>%
column_to_rownames("grid") %>%
as.matrix()
# calculating the *similarity* between grids
grid_modules_dist <- as.matrix(1-vegdist(sqrt(grid_modules), method = "bray"))
# transforming to long format
grid_mudules_dist_m <- grid_modules_dist
grid_mudules_dist_m[lower.tri(grid_mudules_dist_m)] <- NA
diag(grid_mudules_dist_m) <- NA
grid_mudules_dist_m <- melt(grid_mudules_dist_m) %>%
filter(!is.na(value)) %>%
dplyr::rename(grid1 = Var1, grid2 = Var2, module_similarity = value)
return(grid_mudules_dist_m)
}
# setting thresholds for core
core_seq <- seq(1:5)
village_names <- unique(data_asv$village)
nmi_observed_three_villages <- NULL
nmi_diff_core_three_villages <- NULL
modules_similarity_three_villages <- NULL
v="Mandena"
data_asv_village <- data_asv %>%
filter(village == v)
# calculating ASVs degree
asv_degree <- data_asv_village %>%
count(asv_ID) %>%
rename(asv_degree = n)
data_asv_village %<>% left_join(asv_degree, by="asv_ID")
##### observed network
# finding modules
modules_observed <- fun_modularity_analysis(data_asv_village)
# calculating similarity in modules between grids
modules_similarity <- fun_modules_similarity(modules_observed) %>%
mutate(village = v)
# saving results in one table
modules_similarity_three_villages <- rbind(modules_similarity_three_villages, modules_similarity)
View(modules_similarity)
View(modules_similarity_three_villages)
View(modules_similarity)
# calculating NMI
nmi_observed <- fun_nmi_calc(modules_observed, TRUE)
# saving results in one list
nmi_observed_three_villages <- append(nmi_observed_three_villages, nmi_observed)
##### NMI for different values of core microbiome
# calling the function
nmi_diff_core <- fun_modularity_diff_core(data_asv_village, nmi_observed, core_seq)
# saving results in one list
nmi_diff_core_three_villages <- append(nmi_diff_core_three_villages, nmi_diff_core)
nmi_diff_core[[1]]
village_names <- unique(data_asv$village)
nmi_observed_three_villages <- NULL
nmi_diff_core_three_villages <- NULL
modules_similarity_three_villages <- NULL
# for loop for three villages
for (v in village_names) {
data_asv_village <- data_asv %>%
filter(village == v)
# calculating ASVs degree
asv_degree <- data_asv_village %>%
count(asv_ID) %>%
rename(asv_degree = n)
data_asv_village %<>% left_join(asv_degree, by="asv_ID")
##### observed network
# finding modules
modules_observed <- fun_modularity_analysis(data_asv_village)
# calculating similarity in modules between grids
modules_similarity <- fun_modules_similarity(modules_observed) %>%
mutate(village = v)
# saving results in one table
modules_similarity_three_villages <- rbind(modules_similarity_three_villages, modules_similarity)
# calculating NMI
nmi_observed <- fun_nmi_calc(modules_observed, TRUE)
# saving results in one list
nmi_observed_three_villages <- append(nmi_observed_three_villages, nmi_observed)
##### NMI for different values of core microbiome
# calling the function
nmi_diff_core <- fun_modularity_diff_core(data_asv_village, nmi_observed, core_seq)
# saving results in one list
nmi_diff_core_three_villages <- append(nmi_diff_core_three_villages, nmi_diff_core)
}
View(modules_similarity_three_villages)
# reading grid similarity results
grids_similarity_attr <- read_csv("data/data_processed/village_summary.csv")
View(grids_similarity_attr)
nmi_observed_three_villages <- NULL
nmi_diff_core_three_villages <- NULL
modules_similarity_three_villages <- NULL
# for loop for three villages
for (v in village_names) {
data_asv_village <- data_asv %>%
filter(village == v)
# calculating ASVs degree
asv_degree <- data_asv_village %>%
count(asv_ID) %>%
rename(asv_degree = n)
data_asv_village %<>% left_join(asv_degree, by="asv_ID")
##### observed network
# finding modules
modules_observed <- fun_modularity_analysis(data_asv_village)
# calculating similarity in modules between grids
modules_similarity <- fun_modules_similarity(modules_observed) %>%
mutate(village = v)
# saving results in one table
modules_similarity_three_villages <- rbind(modules_similarity_three_villages, modules_similarity)
# calculating NMI
nmi_observed <- fun_nmi_calc(modules_observed, TRUE)
# saving results in one list
nmi_observed_three_villages <- append(nmi_observed_three_villages, nmi_observed)
##### NMI for different values of core microbiome
# calling the function
nmi_diff_core <- fun_modularity_diff_core(data_asv_village, nmi_observed, core_seq)
# saving results in one list
nmi_diff_core_three_villages <- append(nmi_diff_core_three_villages, nmi_diff_core)
}
View(modules_similarity_three_villages)
# function for calculating similarity in modules between grids
fun_modules_similarity <- function(dat) {
# matrix of grid similarity in modules
grid_modules <- dat %>%
group_by(grid, host_group) %>%
summarise(host_n = n_distinct(host_ID)) %>%
spread(host_group, host_n, fill = 0) %>%
mutate(grid = as.character(grid)) %>%
arrange(grid) %>%
column_to_rownames("grid") %>%
as.matrix()
# calculating the *similarity* between grids
grid_modules_dist <- as.matrix(1-vegdist(sqrt(grid_modules), method = "bray"))
# transforming to long format
grid_mudules_dist_m <- grid_modules_dist
grid_mudules_dist_m[lower.tri(grid_mudules_dist_m)] <- NA
diag(grid_mudules_dist_m) <- NA
grid_mudules_dist_m <- melt(grid_mudules_dist_m) %>%
filter(!is.na(value)) %>%
dplyr::rename(grid1 = Var2, grid2 = Var1, module_similarity = value)
return(grid_mudules_dist_m)
}
nmi_observed_three_villages <- NULL
nmi_diff_core_three_villages <- NULL
modules_similarity_three_villages <- NULL
# for loop for three villages
for (v in village_names) {
data_asv_village <- data_asv %>%
filter(village == v)
# calculating ASVs degree
asv_degree <- data_asv_village %>%
count(asv_ID) %>%
rename(asv_degree = n)
data_asv_village %<>% left_join(asv_degree, by="asv_ID")
##### observed network
# finding modules
modules_observed <- fun_modularity_analysis(data_asv_village)
# calculating similarity in modules between grids
modules_similarity <- fun_modules_similarity(modules_observed) %>%
mutate(village = v)
# saving results in one table
modules_similarity_three_villages <- rbind(modules_similarity_three_villages, modules_similarity)
# calculating NMI
nmi_observed <- fun_nmi_calc(modules_observed, TRUE)
# saving results in one list
nmi_observed_three_villages <- append(nmi_observed_three_villages, nmi_observed)
##### NMI for different values of core microbiome
# calling the function
nmi_diff_core <- fun_modularity_diff_core(data_asv_village, nmi_observed, core_seq)
# saving results in one list
nmi_diff_core_three_villages <- append(nmi_diff_core_three_villages, nmi_diff_core)
}
View(modules_similarity_three_villages)
# combining the variables
final_data <- modules_similarity_three_villages %>%
left_join(grids_similarity_attr, by=c("village","grid1","grid2"))
View(final_data)
# combining the variables
final_data <- modules_similarity_three_villages %>%
left_join(grids_similarity_attr, by=c("village","grid1","grid2")) %>%
filter(grid1!="village") # removing the village grid
# checking VIF
library(car)
M <- lm(modules_similarity ~ grid_attr + grid_dist + sm_community, data = final_data)
M <- lm(module_similarity ~ grid_attr + grid_dist + sm_community, data = final_data)
summary(M)
vif(M)
# regression
plot(final_data$module_similarity~final_data$grid_attr)
# regression
plot(final_data$module_similarity~final_data$grid_dist)
# regression
plot(final_data$module_similarity~final_data$sm_community)
# regression
final_data %>%
ggplot(aes(y=module_similarity, x=grid_attr, color=village)) +
geom_point(alpha = 0.8) +
geom_smooth(method = "glm", se=F, method.args = list(family = "gaussian")) +
theme_bw() +
theme(axis.text = element_text(size = 10, color = 'black'), title = element_text(size = 14), strip.text.x = element_text(size=12)) +
labs(x = "Distance Between Grids [km]", y = "Modules Similarity [Bray-Curtis]")
# regression
final_data %>%
ggplot(aes(y=module_similarity, x=grid_attr, color=village)) +
geom_point(alpha = 0.8) +
geom_smooth(method = "glm", se=T, method.args = list(family = "gaussian")) +
theme_bw() +
theme(axis.text = element_text(size = 10, color = 'black'), title = element_text(size = 14), strip.text.x = element_text(size=12)) +
labs(x = "Distance Between Grids [km]", y = "Modules Similarity [Bray-Curtis]")
# regression
final_data %>%
ggplot(aes(y=module_similarity, x=grid_dist, color=village)) +
geom_point(alpha = 0.8) +
geom_smooth(method = "glm", se=F, method.args = list(family = "gaussian")) +
theme_bw() +
theme(axis.text = element_text(size = 10, color = 'black'), title = element_text(size = 14), strip.text.x = element_text(size=12)) +
labs(x = "Distance Between Grids [km]", y = "Modules Similarity [Bray-Curtis]")
# regression
final_data %>%
ggplot(aes(y=module_similarity, x=sm_community, color=village)) +
geom_point(alpha = 0.8) +
geom_smooth(method = "glm", se=F, method.args = list(family = "gaussian")) +
theme_bw() +
theme(axis.text = element_text(size = 10, color = 'black'), title = element_text(size = 14), strip.text.x = element_text(size=12)) +
labs(x = "Distance Between Grids [km]", y = "Modules Similarity [Bray-Curtis]")
# grid distance
final_data %>%
ggplot(aes(y=module_similarity, x=grid_dist, color=village)) +
geom_point(alpha = 0.8) +
geom_smooth(method = "glm", se=F, method.args = list(family = "gaussian")) +
theme_bw() +
theme(axis.text = element_text(size = 10, color = 'black'), title = element_text(size = 14), strip.text.x = element_text(size=12)) +
labs(x = "Distance Between Grids [m]", y = "Modules Similarity [Bray-Curtis]")
# small mammals similarity
final_data %>%
ggplot(aes(y=module_similarity, x=sm_community, color=village)) +
geom_point(alpha = 0.8) +
geom_smooth(method = "glm", se=F, method.args = list(family = "gaussian")) +
theme_bw() +
theme(axis.text = element_text(size = 10, color = 'black'), title = element_text(size = 14), strip.text.x = element_text(size=12)) +
labs(x = "Small Mammals Similarity [Bray-Curtis]", y = "Modules Similarity [Bray-Curtis]")
##### model selection
library(MuMIn)
M <- glm(module_similarity ~ grid_attr + grid_dist + sm_community, data = final_data, family = gausian)
M <- glm(module_similarity ~ grid_attr + grid_dist + sm_community, data = final_data, family = gaussian)
car::vif(M)
# full model
full_model <- glm(module_similarity ~ grid_attr + grid_dist + sm_community, data = final_data, family = gaussian)
# AIC for richness
dredge_modules_similarity <- MuMIn::dredge(full_model)
# full model
full_model <- glm(module_similarity ~ grid_attr + grid_dist + sm_community, data = final_data, family = gaussian, na.action = na.fail)
# AIC for richness
dredge_modules_similarity <- MuMIn::dredge(full_model)
# The best models: delta <= 2
results_modules_similarity <- subset(dredge_modules_similarity, delta <= 2 | df == 2 | df == max(df), recalc.weights = FALSE)
View(results_modules_similarity)
View(dredge_modules_similarity)
# Relative importance
imp <- as.data.frame(MuMIn::sw(dredge_modules_similarity))
var_names <- rownames(imp)
imp_values <- as.vector(imp[[1]])
# Plotting
barplot(imp_values, names.arg=var_names, ylab = "Importance", ylim = c(0,1))
# The best models: delta <= 10
results_modules_similarity <- subset(dredge_modules_similarity, delta <= 10 | df == 2 | df == max(df), recalc.weights = FALSE)
row.names(results_modules_similarity) <- c(1:(nrow(results_modules_similarity)))
?dredge
int_mod<- glm(module_similarity ~ grid_attr + grid_dist*sm_community , data = final_data, family = gaussian, na.action = na.fail)
# AIC for richness
dredge_modules_similarity <- MuMIn::dredge(int_mod)
# full model
# adding the village as a random factor
library(lme4)
?glmer
full_model <- lme4::glmer(module_similarity ~ grid_attr + grid_dist + sm_community + (1|village), data = final_data, family = gaussian, na.action = na.fail)
car::vif(full_model)
# AIC
dredge_modules_similarity <- MuMIn::dredge(full_model)
full_model <- lme4::lmer(module_similarity ~ grid_attr + grid_dist + sm_community + (1|village), data = final_data, family = gaussian, na.action = na.fail)
?lmer
car::vif(full_model)
# AIC
dredge_modules_similarity <- MuMIn::dredge(full_model)
full_model <- lme4::lmer(module_similarity ~ grid_attr + grid_dist + sm_community + (1|village), data = final_data, na.action = na.fail, REML = F)
car::vif(full_model)
# AIC
dredge_modules_similarity <- MuMIn::dredge(full_model)
# combining the variables
final_data <- modules_similarity_three_villages %>%
left_join(grids_similarity_attr, by=c("village","grid1","grid2")) %>%
mutate(grid_dist = sqrt(grid_dist)) %>%
filter(grid1!="village") # removing the village grid
full_model <- lme4::lmer(module_similarity ~ grid_attr + grid_dist + sm_community + (1|village), data = final_data, na.action = na.fail, REML = F)
car::vif(full_model)
# AIC
dredge_modules_similarity <- MuMIn::dredge(full_model)
full_model <- lme4::lmer(module_similarity ~ grid_attr + grid_dist + sm_community + (1|village), data = final_data, na.action = na.fail, REML = T)
car::vif(full_model)
# AIC
dredge_modules_similarity <- MuMIn::dredge(full_model)
View(full_model)
summary(full_model)
lmer(module_similarity ~  sm_community + (1|village), data = final_data, na.action = na.fail, REML = T)
a=lmer(module_similarity ~  sm_community + (1|village), data = final_data, na.action = na.fail, REML = T)
summary(a)
qqPlot(final_data$module_similarity)
shapiro.test(final_data$module_similarity)
qqPlot(final_data$grid_attr)
shapiro.test(final_data$grid_attr)
shapiro.test(final_data$grid_dist)
shapiro.test(final_data$sm_community)
shapiro.test(final_data$module_similarity)
library(fitdistrplus)
descdist(final_data$module_similarity, discrete = FALSE)
normal_dist <- fitdist(final_data$module_similarity, "norm")
plot(normal_dist)
?fitdist
normal_dist <- fitdist(final_data$module_similarity, "nbinom")
normal_dist <- fitdist(final_data$module_similarity, "norm")
normal_dist$estimate
normal_dist$aic
normal_dist$cor
normal_dist <- fitdist(final_data$module_similarity, "gama")
normal_dist <- fitdist(final_data$module_similarity, "gamma")
plot(normal_dist)
?nlmer
install.packages("nlme")
install.packages("nlme")
install.packages("nlme")
install.packages("nlme")
library(nlme)
full_model <- lme(module_similarity ~ grid_attr + grid_dist + sm_community + (1|village), data = final_data, na.action = na.fail, REML = T)
full_model <- lme4::glmer(module_similarity ~ grid_attr + grid_dist + sm_community + (1|village), data = final_data, family = gaussian, na.action = na.fail, REML = T)
full_model <- lme4::glmer(module_similarity ~ grid_attr + grid_dist + sm_community + (1|village), data = final_data, family = gaussian, na.action = na.fail)
# AIC
dredge_modules_similarity <- MuMIn::dredge(full_model)
full_model <- lme4::lmer(module_similarity ~ grid_attr + grid_dist + sm_community + (1|village), data = final_data, REML = F, na.action = na.fail)
# AIC
dredge_modules_similarity <- MuMIn::dredge(full_model)
full_model <- lme4::lmer(module_similarity ~ grid_attr + grid_dist + sm_community + (1|village), data = final_data, REML = F, na.action = na.fail)
# AIC
dredge_modules_similarity <- MuMIn::dredge(full_model)
full_model2 <- lme4::lmer(module_similarity ~ grid_attr + grid_dist + sm_community + (1|village), data = final_data, REML = F, na.action = na.fail)
# AIC
dredge_modules_similarity <- MuMIn::dredge(full_model2)
# saving the results
write_csv(final_data, "data/data_processed/final_modularity_data.csv")
library(tidyverse)
library(magrittr)
library(ggplot2)
library(vegan)
library(igraph)
library(reshape2)
library(infomapecology)
library(aricode)
library(cowplot)
# saving the results
write_csv(final_data, "data/data_processed/final_modularity_data.csv")
full_model <- lme4::lmer(module_similarity ~ grid_attr + grid_dist + sm_community + (1|village), data = final_data, REML = F, na.action = na.fail)
library(lme4)
##### model selection
library(MuMIn)
full_model <- lme4::lmer(module_similarity ~ grid_attr + grid_dist + sm_community + (1|village), data = final_data, REML = F, na.action = na.fail)
# AIC
dredge_modules_similarity <- MuMIn::dredge(full_model)
full_model <- lme4::lmer(module_similarity ~ grid_attr + grid_dist + sm_community , data = final_data, REML = F, na.action = na.fail)
# The best models: delta <= 10
results_modules_similarity <- subset(dredge_modules_similarity, delta <= 10 | df == 2 | df == max(df), recalc.weights = FALSE)
# AIC
dredge_modules_similarity <- MuMIn::dredge(full_model)
View(dredge_modules_similarity)
full_model <- lme4::lmer(module_similarity ~ grid_attr + grid_dist + sm_community + (1|village), data = final_data, REML = T, na.action = na.fail)
# AIC
dredge_modules_similarity <- MuMIn::dredge(full_model)
full_model <- lme4::lmer(module_similarity ~ grid_attr + grid_dist + sm_community + (1|village), data = final_data, REML = F, na.action = na.fail)
# AIC
dredge_modules_similarity <- MuMIn::dredge(full_model)
# The best models: delta <= 10
results_modules_similarity <- subset(dredge_modules_similarity, delta <= 10 | df == 2 | df == max(df), recalc.weights = FALSE)
View(results_modules_similarity)
# Relative importance
imp <- as.data.frame(MuMIn::sw(dredge_modules_similarity))
var_names <- rownames(imp)
imp_values <- as.vector(imp[[1]])
# Plotting
barplot(imp_values, names.arg=var_names, ylab = "Importance", ylim = c(0,1))
# small mammals similarity
final_data %>%
ggplot(aes(y=module_similarity, x=sm_community, color=village)) +
geom_point(alpha = 0.8) +
geom_smooth(method = "glm", se=F, method.args = list(family = "gaussian")) +
theme_bw() +
theme(axis.text = element_text(size = 10, color = 'black'), title = element_text(size = 14), strip.text.x = element_text(size=12)) +
labs(x = "Small Mammals Similarity [Bray-Curtis]", y = "Modules Similarity [Bray-Curtis]")
# grid distance
final_data %>%
ggplot(aes(y=module_similarity, x=grid_dist, color=village)) +
geom_point(alpha = 0.8) +
geom_smooth(method = "glm", se=F, method.args = list(family = "gaussian")) +
theme_bw() +
theme(axis.text = element_text(size = 10, color = 'black'), title = element_text(size = 14), strip.text.x = element_text(size=12)) +
labs(x = "Distance Between Grids [m]", y = "Modules Similarity [Bray-Curtis]")
car::vif(full_model)
# The best models: delta <= 10
results_modules_similarity <- subset(dredge_modules_similarity, delta <= 10 | df == 2 | df == max(df), recalc.weights = FALSE)
full_model <- lme4::lmer(module_similarity ~ grid_attr + grid_dist + sm_community + (1|village), data = final_data, REML = F, na.action = na.fail)
# AIC
dredge_modules_similarity <- MuMIn::dredge(full_model)
# The best models: delta <= 10
results_modules_similarity <- subset(dredge_modules_similarity, delta <= 10 | df == 2 | df == max(df), recalc.weights = FALSE)
# The best models: delta <= 10
results_modules_similarity <- subset(dredge_modules_similarity, delta <= 10 | df == 3 | df == max(df), recalc.weights = FALSE)
row.names(results_modules_similarity) <- c(1:(nrow(results_modules_similarity)))
detach("package:lme4", unload = TRUE)
library(nlme)
