geom_tile(color='white') +
theme_classic() +
scale_fill_viridis_c(limits = c(0, 1)) +
theme(axis.text = element_text(size = 10, color = 'black'), title = element_text(size = 14), strip.text.x = element_text(size=12)) +
labs(x='Module ID', y='Land Use')
print(g)
# modules size
g <- data_asv_s %>%
group_by(host_group) %>%
summarise(n = n_distinct(host_ID)) %>%
ggplot(aes(x=n)) +
geom_histogram(binwidth = 1) +
theme_bw() +
theme(axis.text = element_text(size = 14, color = 'black'), title = element_text(size = 20), strip.text.x = element_text(size=12)) +
labs(x="Module Size", y="No. of Modules")
print(g)
hosts <- data_asv_s %>% distinct(host_ID, grid, host_group)
nmi_obs <- aricode::NMI(hosts$grid, hosts$host_group)
nmi_shuff <- vector(length = 1000)
for(i in 1:1000) {
# shuffling the grid attribute
hosts_shuff <- hosts %>%
mutate(grid = sample(grid,nrow(hosts)))
# calculating nmi
nmi_shuff[i] <- aricode::NMI(hosts_shuff$grid, hosts_shuff$host_group)
}
# plotting
p <- length(nmi_shuff[nmi_shuff>nmi_obs]) / length(nmi_shuff)
g <- as.data.frame(nmi_shuff) %>%
ggplot(aes(nmi_shuff)) +
geom_histogram() +
theme_bw() +
geom_vline(xintercept = nmi_obs, linetype='dashed', color="red") +
theme(axis.text = element_text(size = 14, color = 'black'), title = element_text(size = 20)) +
labs(x="NMI", y="No. of Shuffled Networks")+
annotate("text", x=max(nmi_obs), y=100, label=paste('p-value =',p))
print(g)
hosts <- data_asv_s %>% distinct(host_ID, village, host_group)
nmi_obs <- aricode::NMI(hosts$village, hosts$host_group)
n_module_grid <- data_asv_s %>%
group_by(host_group) %>%
summarise(n_grid = n_distinct(grid))
#a=quantile(n_asv$n, c(0.25,0.75))
n_asv <- data_asv_s %>%
count(asv_ID) %>%
left_join(modules_asv %>% dplyr::select(asv_ID, asv_group), by="asv_ID") %>%
left_join(n_module_grid, by = c("asv_group"="host_group")) %>%
mutate(n = ifelse(n<5,"1-4", ifelse(n>=10,"10+", "5-9"))) %>%
mutate(n = factor(n, levels = c("1-4","5-9","10+")))
n_asv %>%
ggplot(aes(x=n, y=n_grid, fill=n)) +
geom_boxplot() +
theme_bw() +
theme(axis.text = element_text(size = 14, color = 'black'), title = element_text(size = 20), legend.position = "none") +
labs(x="ASVs Degree", y="Modules' No. of Land Uses")
ggsave("n_grids_modules.pdf", path = "grid_modularity_files", device = "pdf")
habitat.raw <- read_csv("data_raw/Trap_Plots.csv")
View(habitat.raw)
habitat <- habitat.raw %>%
filter(village == "Mandena") %>%
mutate(grid_name = case_when(grid_name=="Primary forest" ~ "semi-intact_forest",
grid_name=="Degraded forest" ~ "semi-intact_forest",
grid_name=="Secondary forest" ~ "secondary_forest",
grid_name=="Savoka" ~ "brushy_regrowth",
grid_name=="Sugar cane" ~ "agriculture",
grid_name=="Mixed agricultural fields" ~ "agriculture",
grid_name=="Vanilla, coffee, banana fields" ~ "agriculture",
grid_name=="Rice field" ~ "flooded_rice",
grid_name=="Vanilla" ~ "agroforest",
grid_name=="Village" ~ "village")) %>%
select(village, grid_name, plot, square, dead_logs, tree_dbh, tree_height, #omiting crown distance
liana_number, herbaceous_height, herbaceous_cover, canopy_cover) #omitting observations and season
## deal with multitrunk trees by taking sqrt of sum of square DBH of each stem
habitat <- habitat %>%
separate(tree_dbh, c("dbh1", "dbh2", "dbh3"), sep = ",") %>% #using unique(habitat$tree_dbh) see max of 3 stems, give each their own column
mutate(across(c(dbh1, dbh2, dbh3), as.numeric), #make numeric
across(c(dbh1, dbh2, dbh3), ~ifelse(is.na(.x), 0, .x)), #make na into 0
tree_dbh = dbh1^2+dbh2^2+dbh3^2, #sum sq dbhs
tree_dbh = ifelse(tree_dbh == 0, NA, sqrt(tree_dbh))) %>% #sqrt of sum, if 0 make NA (no trees)
select(-dbh1, -dbh2, -dbh3)
## deal with the herbaceous_height "x to x"
habitat <- habitat %>%
mutate(herbaceous_height = case_when(herbaceous_height == "0.4 to 1.5" ~ mean(c(0.4, 1.5)),
herbaceous_height == "1.5 to 2" ~ mean(c(1.5, 2)),
herbaceous_height == "0.3 to 1" ~ mean(c(0.3, 1)),
herbaceous_height == "0,3 to 1" ~ mean(c(0.3, 1)),
herbaceous_height == "0 to 1" ~ mean(c(0, 1)),
herbaceous_height == "0 to 2" ~ mean(c(0, 2)),
TRUE ~ as.numeric(herbaceous_height)))
# add pitfall column
habitat <- habitat %>%
mutate(pitfall = ifelse(str_detect(plot, "Pitfall"), "Pitfall", "Grid"),
pitfall_line = case_when(str_detect(plot, "Pitfall 1") ~ 1,
str_detect(plot, "Pitfall 2") ~ 2,
str_detect(plot, "Pitfall 3") ~ 3,
str_detect(plot, "Pitfall 4") ~ 4,
str_detect(plot, "Pitfall 5") ~ 5,
str_detect(plot, "Pitfall 6") ~ 6,
str_detect(plot, "Pitfall 7") ~ 7,
str_detect(plot, "Pitfall 8") ~ 8,
str_detect(plot, "Pitfall 9") ~ 9,
str_detect(plot, "Pitfall 10") ~ 10,
str_detect(plot, "Pitfall 11") ~ 11,
str_detect(plot, "Pitfall 12") ~ 12,
TRUE ~ 0))
## make a trees df
trees <- habitat %>%
select(village, grid_name, pitfall, plot, square, tree_height, tree_dbh)
## create a new df individual tree measurements
squares <- habitat %>%
mutate(tree = ifelse(is.na(tree_dbh), 0, 1)) %>% ## count the number of trees in each square
group_by(village, grid_name, plot, square) %>%
mutate(n_trees = sum(tree)) %>%
ungroup() %>%
select(-tree_height, -tree_dbh, -tree) %>% # remove tree info from habitat
distinct()
plot_sum <- squares %>%
mutate(across(c(n_trees, dead_logs,
liana_number, herbaceous_height,
herbaceous_cover, canopy_cover))) %>%
group_by(pitfall, pitfall_line, village, grid_name, plot) %>%
summarise(n_trees = sum(n_trees, na.rm=T),
n_logs = sum(dead_logs, na.rm=T),
n_liana = sum(liana_number, na.rm=T),
m_herb_ht = mean(herbaceous_height, na.rm=T),
m_herb_cv = mean(herbaceous_cover, na.rm = T),
m_canopy_cv = mean(canopy_cover, na.rm = T)) %>%
ungroup() %>%
mutate(across(everything(), ~replace(. , is.nan(.), 0)))
View(plot_sum)
habitat.raw <- read_csv("data_raw/Trap_Plots.csv")
View(habitat.raw)
knitr::opts_chunk$set(results = "asis", message=FALSE, warning=FALSE, cache=TRUE, eval = TRUE, dev = c('png'), out.width = '100%', out.height='40%')
rm(list=ls())
data_asv <- read_csv("../data/data_processed/microbiome/data_asv_rra0.01_th1000.csv") %>%
filter(host_species == "Rattus rattus" & grid!="village")
View(data_asv)
# ASVs taxonomy
asv_taxa <- read_delim("data/data_raw/data_microbiome/ASVs_all_merged_taxonomy.tsv") %>%
select(ASV, Family)
# ASVs taxonomy
asv_taxa <- read_delim("../data/data_raw/data_microbiome/ASVs_all_merged_taxonomy.tsv") %>%
select(ASV, Family)
data_asv %<>% left_join(asv_taxa, by=c("asv_ID"="ASV"))
data_asv_family <- data_asv %>%
group_by(host_ID, village, host_species, grid, season, mass, sex, dist_village, Family) %>%
summarise(reads = sum(reads)) %>%
filter(!(is.na(Family)))
data_asv_family <- data_asv %>%
group_by(host_ID, village, host_species, grid, season, Family) %>%
summarise(reads = sum(reads)) %>%
filter(!(is.na(Family)))
View(data_asv_family)
data_asv_family <- data_asv %>%
group_by(host_ID, village, host_species, grid, season, Family) %>%
summarise(reads = sum(reads)) %>%
rename(asv_ID = Family) %>%
filter(!(is.na(Family)))
data_asv_family <- data_asv %>%
group_by(host_ID, village, host_species, grid, season, Family) %>%
summarise(reads = sum(reads)) %>%
rename(asv_ID = Family) %>%
filter(!(is.na(asv_ID)))
data_asv <- data_asv_family
# first of all, run this chunk of code.
# this code does all the modularity analysis using the functions in "modularity_analysis_functions".
# There is a loop runs for the three villages, and all the analysis is done separately for each village.
# the output of the code is variables holding the final results figures (the output of the functions used)
# setting thresholds for core
core_seq <- seq(1:2)
village_names <- unique(data_asv$village)
nmi_observed_three_villages <- NULL
nmi_diff_core_three_villages <- NULL
modules_similarity_three_villages <- NULL
asv_degree_distribution_three_villages <- NULL
modules_three_villages <- NULL
modules_size_three_villages <- NULL
modules_grid_three_villages <- NULL
# for loop for three villages
for (v in village_names) {
data_asv_village <- data_asv %>%
filter(village == v)
# calculating ASVs degree
asv_degree <- data_asv_village %>%
count(asv_ID) %>%
rename(asv_degree = n)
data_asv_village %<>% left_join(asv_degree, by="asv_ID")
##### observed network
# finding modules
modules_observed <- fun_modularity_analysis(data_asv_village)
# calculating similarity in modules between grids
modules_similarity <- fun_modules_similarity(modules_observed) %>%
mutate(village = v)
# saving results in one table
modules_similarity_three_villages <- rbind(modules_similarity_three_villages, modules_similarity)
# ASVs degree distribution
asv_degree_distribution <- fun_asv_degree_distribution(data_asv_village)
asv_degree_distribution_three_villages <- append(asv_degree_distribution_three_villages, asv_degree_distribution)
# figure of modules
modules <- fun_modules(modules_observed)
modules_three_villages <- append(modules_three_villages, modules)
# modules size
modules_size <- fun_module_size(modules_observed)
modules_size_three_villages <- append(modules_size_three_villages, modules_size)
# Number of land uses per module
modules_grid <- fun_module_grid(modules_observed)
modules_grid_three_villages <- append(modules_grid_three_villages, modules_grid)
# calculating NMI
nmi_observed <- fun_nmi_calc(modules_observed, TRUE)
# saving results in one list
nmi_observed_three_villages <- append(nmi_observed_three_villages, nmi_observed)
##### NMI for different values of core microbiome
# calling the function
nmi_diff_core <- fun_modularity_diff_core(data_asv_village, nmi_observed, core_seq)
# saving results in one list
nmi_diff_core_three_villages <- append(nmi_diff_core_three_villages, nmi_diff_core)
}
source("modularity_analysis_functions.R", local = knitr::knit_global())
# reading the microbiome data
# working only with Rattus from the three villages
# removing the 'village' grid from the analysis
data_asv <- read_csv("../data/data_processed/microbiome/data_asv_rra0.01_th1000.csv") %>%
filter(host_species == "Rattus rattus" & grid!="village")
# ASVs taxonomy
asv_taxa <- read_delim("../data/data_raw/data_microbiome/ASVs_all_merged_taxonomy.tsv") %>%
select(ASV, Family)
data_asv %<>% left_join(asv_taxa, by=c("asv_ID"="ASV"))
data_asv_family <- data_asv %>%
group_by(host_ID, village, host_species, grid, season, Family) %>%
summarise(reads = sum(reads)) %>%
rename(asv_ID = Family) %>%
filter(!(is.na(asv_ID)))
data_asv <- data_asv_family
# first of all, run this chunk of code.
# this code does all the modularity analysis using the functions in "modularity_analysis_functions".
# There is a loop runs for the three villages, and all the analysis is done separately for each village.
# the output of the code is variables holding the final results figures (the output of the functions used)
# setting thresholds for core
core_seq <- seq(1:2)
village_names <- unique(data_asv$village)
nmi_observed_three_villages <- NULL
nmi_diff_core_three_villages <- NULL
modules_similarity_three_villages <- NULL
asv_degree_distribution_three_villages <- NULL
modules_three_villages <- NULL
modules_size_three_villages <- NULL
modules_grid_three_villages <- NULL
# for loop for three villages
for (v in village_names) {
data_asv_village <- data_asv %>%
filter(village == v)
# calculating ASVs degree
asv_degree <- data_asv_village %>%
count(asv_ID) %>%
rename(asv_degree = n)
data_asv_village %<>% left_join(asv_degree, by="asv_ID")
##### observed network
# finding modules
modules_observed <- fun_modularity_analysis(data_asv_village)
# calculating similarity in modules between grids
modules_similarity <- fun_modules_similarity(modules_observed) %>%
mutate(village = v)
# saving results in one table
modules_similarity_three_villages <- rbind(modules_similarity_three_villages, modules_similarity)
# ASVs degree distribution
asv_degree_distribution <- fun_asv_degree_distribution(data_asv_village)
asv_degree_distribution_three_villages <- append(asv_degree_distribution_three_villages, asv_degree_distribution)
# figure of modules
modules <- fun_modules(modules_observed)
modules_three_villages <- append(modules_three_villages, modules)
# modules size
modules_size <- fun_module_size(modules_observed)
modules_size_three_villages <- append(modules_size_three_villages, modules_size)
# Number of land uses per module
modules_grid <- fun_module_grid(modules_observed)
modules_grid_three_villages <- append(modules_grid_three_villages, modules_grid)
# calculating NMI
nmi_observed <- fun_nmi_calc(modules_observed, TRUE)
# saving results in one list
nmi_observed_three_villages <- append(nmi_observed_three_villages, nmi_observed)
##### NMI for different values of core microbiome
# calling the function
nmi_diff_core <- fun_modularity_diff_core(data_asv_village, nmi_observed, core_seq)
# saving results in one list
nmi_diff_core_three_villages <- append(nmi_diff_core_three_villages, nmi_diff_core)
}
View(data_asv)
View(data_asv_village)
View(asv_degree)
rm(list=ls())
source("modularity_analysis_functions.R", local = knitr::knit_global())
# reading the microbiome data
# working only with Rattus from the three villages
# removing the 'village' grid from the analysis
data_asv <- read_csv("../data/data_processed/microbiome/data_asv_rra0.01_th1000.csv") %>%
filter(host_species == "Rattus rattus" & grid!="village")
# ASVs taxonomy
asv_taxa <- read_delim("../data/data_raw/data_microbiome/ASVs_all_merged_taxonomy.tsv") %>%
select(ASV, Family)
data_asv %<>% left_join(asv_taxa, by=c("asv_ID"="ASV"))
data_asv_family <- data_asv %>%
group_by(host_ID, village, host_species, grid, season, Family) %>%
summarise(reads = sum(reads)) %>%
rename(asv_ID = Family) %>%
filter(!(is.na(asv_ID)))
data_asv <- data_asv_family
# first of all, run this chunk of code.
# this code does all the modularity analysis using the functions in "modularity_analysis_functions".
# There is a loop runs for the three villages, and all the analysis is done separately for each village.
# the output of the code is variables holding the final results figures (the output of the functions used)
# setting thresholds for core
core_seq <- seq(1:2)
village_names <- unique(data_asv$village)
nmi_observed_three_villages <- NULL
nmi_diff_core_three_villages <- NULL
modules_similarity_three_villages <- NULL
asv_degree_distribution_three_villages <- NULL
modules_three_villages <- NULL
modules_size_three_villages <- NULL
modules_grid_three_villages <- NULL
# for loop for three villages
for (v in village_names) {
data_asv_village <- data_asv %>%
filter(village == v)
# calculating ASVs degree
asv_degree <- data_asv_village %>%
count(asv_ID) %>%
rename(asv_degree = n)
data_asv_village %<>% left_join(asv_degree, by="asv_ID")
##### observed network
# finding modules
modules_observed <- fun_modularity_analysis(data_asv_village)
# calculating similarity in modules between grids
modules_similarity <- fun_modules_similarity(modules_observed) %>%
mutate(village = v)
# saving results in one table
modules_similarity_three_villages <- rbind(modules_similarity_three_villages, modules_similarity)
# ASVs degree distribution
asv_degree_distribution <- fun_asv_degree_distribution(data_asv_village)
asv_degree_distribution_three_villages <- append(asv_degree_distribution_three_villages, asv_degree_distribution)
# figure of modules
modules <- fun_modules(modules_observed)
modules_three_villages <- append(modules_three_villages, modules)
# modules size
modules_size <- fun_module_size(modules_observed)
modules_size_three_villages <- append(modules_size_three_villages, modules_size)
# Number of land uses per module
modules_grid <- fun_module_grid(modules_observed)
modules_grid_three_villages <- append(modules_grid_three_villages, modules_grid)
# calculating NMI
nmi_observed <- fun_nmi_calc(modules_observed, TRUE)
# saving results in one list
nmi_observed_three_villages <- append(nmi_observed_three_villages, nmi_observed)
##### NMI for different values of core microbiome
# calling the function
nmi_diff_core <- fun_modularity_diff_core(data_asv_village, nmi_observed, core_seq)
# saving results in one list
nmi_diff_core_three_villages <- append(nmi_diff_core_three_villages, nmi_diff_core)
}
View(asv_degree)
View(asv_degree)
rm(list=ls())
source("modularity_analysis_functions.R", local = knitr::knit_global())
# reading the microbiome data
# working only with Rattus from the three villages
# removing the 'village' grid from the analysis
data_asv <- read_csv("../data/data_processed/microbiome/data_asv_rra0.01_th1000.csv") %>%
filter(host_species == "Rattus rattus" & grid!="village")
# ASVs taxonomy
asv_taxa <- read_delim("../data/data_raw/data_microbiome/ASVs_all_merged_taxonomy.tsv") %>%
select(ASV, Family)
data_asv %<>% left_join(asv_taxa, by=c("asv_ID"="ASV"))
data_asv_family <- data_asv %>%
group_by(host_ID, village, host_species, grid, season, Family) %>%
summarise(reads = sum(reads)) %>%
rename(asv_ID = Family) %>%
mutate(asv_ID = as.factor(asv_ID)) %>%
filter(!(is.na(asv_ID)))
data_asv <- data_asv_family
# first of all, run this chunk of code.
# this code does all the modularity analysis using the functions in "modularity_analysis_functions".
# There is a loop runs for the three villages, and all the analysis is done separately for each village.
# the output of the code is variables holding the final results figures (the output of the functions used)
# setting thresholds for core
core_seq <- seq(1:2)
village_names <- unique(data_asv$village)
nmi_observed_three_villages <- NULL
nmi_diff_core_three_villages <- NULL
modules_similarity_three_villages <- NULL
asv_degree_distribution_three_villages <- NULL
modules_three_villages <- NULL
modules_size_three_villages <- NULL
modules_grid_three_villages <- NULL
# for loop for three villages
for (v in village_names) {
data_asv_village <- data_asv %>%
filter(village == v)
# calculating ASVs degree
asv_degree <- data_asv_village %>%
count(asv_ID) %>%
rename(asv_degree = n)
data_asv_village %<>% left_join(asv_degree, by="asv_ID")
##### observed network
# finding modules
modules_observed <- fun_modularity_analysis(data_asv_village)
# calculating similarity in modules between grids
modules_similarity <- fun_modules_similarity(modules_observed) %>%
mutate(village = v)
# saving results in one table
modules_similarity_three_villages <- rbind(modules_similarity_three_villages, modules_similarity)
# ASVs degree distribution
asv_degree_distribution <- fun_asv_degree_distribution(data_asv_village)
asv_degree_distribution_three_villages <- append(asv_degree_distribution_three_villages, asv_degree_distribution)
# figure of modules
modules <- fun_modules(modules_observed)
modules_three_villages <- append(modules_three_villages, modules)
# modules size
modules_size <- fun_module_size(modules_observed)
modules_size_three_villages <- append(modules_size_three_villages, modules_size)
# Number of land uses per module
modules_grid <- fun_module_grid(modules_observed)
modules_grid_three_villages <- append(modules_grid_three_villages, modules_grid)
# calculating NMI
nmi_observed <- fun_nmi_calc(modules_observed, TRUE)
# saving results in one list
nmi_observed_three_villages <- append(nmi_observed_three_villages, nmi_observed)
##### NMI for different values of core microbiome
# calling the function
nmi_diff_core <- fun_modularity_diff_core(data_asv_village, nmi_observed, core_seq)
# saving results in one list
nmi_diff_core_three_villages <- append(nmi_diff_core_three_villages, nmi_diff_core)
}
View(data_asv_village)
?count
setwd("~/Documents/GitHub/Microbiome_Structure_Madagascar")
source("modularity_analysis_functions.R", local = knitr::knit_global())
# reading the microbiome data
# working only with Rattus from the three villages
# removing the 'village' grid from the analysis
data_asv <- read_csv("../data/data_processed/microbiome/data_asv_rra0.01_th1000.csv") %>%
filter(host_species == "Rattus rattus" & grid!="village")
# ASVs taxonomy
asv_taxa <- read_delim("../data/data_raw/data_microbiome/ASVs_all_merged_taxonomy.tsv") %>%
select(ASV, Family)
data_asv %<>% left_join(asv_taxa, by=c("asv_ID"="ASV"))
data_asv_family <- data_asv %>%
group_by(host_ID, village, host_species, grid, season, Family) %>%
summarise(reads = sum(reads)) %>%
rename(asv_ID = Family) %>%
mutate(asv_ID = as.factor(asv_ID)) %>%
filter(!(is.na(asv_ID)))
data_asv <- data_asv_family
# first of all, run this chunk of code.
# this code does all the modularity analysis using the functions in "modularity_analysis_functions".
# There is a loop runs for the three villages, and all the analysis is done separately for each village.
# the output of the code is variables holding the final results figures (the output of the functions used)
# setting thresholds for core
core_seq <- seq(1:2)
village_names <- unique(data_asv$village)
nmi_observed_three_villages <- NULL
nmi_diff_core_three_villages <- NULL
modules_similarity_three_villages <- NULL
asv_degree_distribution_three_villages <- NULL
modules_three_villages <- NULL
modules_size_three_villages <- NULL
modules_grid_three_villages <- NULL
# for loop for three villages
for (v in village_names) {
data_asv_village <- data_asv %>%
filter(village == v)
# calculating ASVs degree
asv_degree <- data_asv_village %>%
count(asv_ID) %>%
rename(asv_degree = n)
data_asv_village %<>% left_join(asv_degree, by="asv_ID")
##### observed network
# finding modules
modules_observed <- fun_modularity_analysis(data_asv_village)
# calculating similarity in modules between grids
modules_similarity <- fun_modules_similarity(modules_observed) %>%
mutate(village = v)
# saving results in one table
modules_similarity_three_villages <- rbind(modules_similarity_three_villages, modules_similarity)
# ASVs degree distribution
asv_degree_distribution <- fun_asv_degree_distribution(data_asv_village)
asv_degree_distribution_three_villages <- append(asv_degree_distribution_three_villages, asv_degree_distribution)
# figure of modules
modules <- fun_modules(modules_observed)
modules_three_villages <- append(modules_three_villages, modules)
# modules size
modules_size <- fun_module_size(modules_observed)
modules_size_three_villages <- append(modules_size_three_villages, modules_size)
# Number of land uses per module
modules_grid <- fun_module_grid(modules_observed)
modules_grid_three_villages <- append(modules_grid_three_villages, modules_grid)
# calculating NMI
nmi_observed <- fun_nmi_calc(modules_observed, TRUE)
# saving results in one list
nmi_observed_three_villages <- append(nmi_observed_three_villages, nmi_observed)
##### NMI for different values of core microbiome
# calling the function
nmi_diff_core <- fun_modularity_diff_core(data_asv_village, nmi_observed, core_seq)
# saving results in one list
nmi_diff_core_three_villages <- append(nmi_diff_core_three_villages, nmi_diff_core)
}
data_asv_village <- data_asv %>%
filter(village == v)
View(data_asv_village)
# calculating ASVs degree
asv_degree <- data_asv_village %>%
count(asv_ID) %>%
rename(asv_degree = n)
