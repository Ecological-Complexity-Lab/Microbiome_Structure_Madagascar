# Generate sample data for land use distances
land_use_distances <- matrix(runif(49, min = 1, max = 100), nrow = 7)
# Create the bipartite graph object
bipartite_graph <- graph_from_data_frame(module_nodes, directed = FALSE)
# Assign node attributes
V(bipartite_graph)$type <- ifelse(grepl("Module", V(bipartite_graph)$name), "module", "land_use")
V(bipartite_graph)$abundance <- ifelse(V(bipartite_graph)$type == "module", module_nodes$abundance, NA)
# Set land use distances
edge_list <- get.edgelist(bipartite_graph)
edge_distances <- land_use_distances[edge_list[,2], edge_list[,1]]
View(land_use_distances)
View(module_nodes)
# Plot the bipartite network with pie charts representing host relative abundance
plot(bipartite_graph, layout = layout_as_bipartite,
vertex.label = NA, edge.arrow.size = 0,
vertex.shape = ifelse(V(bipartite_graph)$type == "module", "pie", "circle"),
vertex.size = ifelse(V(bipartite_graph)$type == "module", 10, 5),
vertex.label.dist = ifelse(V(bipartite_graph)$type == "module", 1.5, 0.5),
vertex.label.cex = 0.7,
edge.width = 1,
vertex.pie = ifelse(V(bipartite_graph)$type == "module", V(bipartite_graph)$abundance, NA),
vertex.pie.color = rainbow(7),
vertex.pie.lwd = 1)
data_modules_mandena <- data_modules %>%
filter(village=="Mandena")
data_modules <- read_csv("../results/modules_table_three_villages.csv")
data_modules_mandena <- data_modules %>%
filter(village=="Mandena")
# modules size
modules_size <- data_modules_mandena %>%
group_by(host_group) %>%
summarise(n = n_distinct(host_ID)) %>%
mutate(n = sqrt(n))
# preparing the pie charts data
# a list of host abundance in the 7 grids for every module
modules_pie <- data_modules_mandena %>%
group_by(host_group, grid) %>%
summarise(n = n_distinct(host_ID)) %>%
spread(grid, n, fill = 0) %>%
column_to_rownames("host_group") %>%
as.matrix()
# converting to list
module_pie_list <- split(modules_pie, seq(nrow(modules_pie)))
View(data_modules)
View(modules_pie)
set.seed(123)
# Generate sample data for module-node connections
module_nodes <- data.frame(
module = rep(1:80, each = 7),
node = rep(1:7, times = 80),
abundance = runif(560, min = 0, max = 100)
)
# Generate sample data for land use distances
land_use_distances <- matrix(runif(49, min = 1, max = 100), nrow = 7)
# Create the bipartite graph object
bipartite_graph <- graph_from_data_frame(module_nodes, directed = FALSE)
# Assign node attributes
V(bipartite_graph)$type <- ifelse(grepl("Module", V(bipartite_graph)$name), "module", "land_use")
V(bipartite_graph)$abundance <- ifelse(V(bipartite_graph)$type == "module", module_nodes$abundance, NA)
# Set land use distances
edge_list <- get.edgelist(bipartite_graph)
edge_distances <- land_use_distances[edge_list[,2], edge_list[,1]]
View(modules_pie)
# making the network
network_mat <- t(modules_pie)
View(network_mat)
network_g <- igraph::graph_from_bi_adjacency_matrix(network_mat, mode = "undirected")
?graph_from_bi_adjacency_matrix
# making the network
network_data <- t(modules_pie) %>%
as.data.frame() %>%
```
network_data <- t(modules_pie) %>%
as.data.frame()
View(network_data)
# making the network
network_data <- as.data.frame(modules_pie) %>%
rownames_to_column("host_group")
?gather
# making the network
network_data <- as.data.frame(modules_pie) %>%
rownames_to_column("host_group") %>%
gather("grid", "weight", agriculture:village)
# making the network
network_data <- as.data.frame(modules_pie) %>%
rownames_to_column("host_group") %>%
gather("grid", "weight", agriculture:village) %>%
filter(weight > 0)
View(modules_pie)
node_type <- tibble(name = c(colnames(modules_pie), rownames(modules_pie)),
type = c(rep(0,7), rep(1,86)))
View(node_type)
node_type <- c(rep(0,7), rep(1,86))
names(node_type) <- c(colnames(modules_pie), rownames(modules_pie))
node_type
modules_graph <- make_bipartite_graph(node_type, network_data)
modules_graph <- graph.adjacency(t(modules_pie))
modules_graph <- graph.data.frame(network_data)
plot(modules_graph)
plot(modules_graph,
layout_as_bipartite())
plot(modules_graph,
layout_as_bipartite(modules_graph))
vertex_attr(modules_graph)
node_type <- data.frame(name = c(colnames(modules_pie), rownames(modules_pie)),
type = c(rep(0,7), rep(1,86)))
modules_graph <- graph.data.frame(network_data, vertices = node_type)
plot(modules_graph,
layout_as_bipartite(modules_graph))
plot(modules_graph)
plot(modules_graph,
layout=layout_as_bipartite)
modules_graph <- graph.data.frame(network_data, vertices = node_type, directed = FALSE)
plot(modules_graph,
layout=layout_as_bipartite)
node_type <- data.frame(name = c(colnames(modules_pie), rownames(modules_pie)),
type = c(rep(1,7), rep(0,86)))
modules_graph <- graph.data.frame(network_data, vertices = node_type, directed = FALSE)
plot(modules_graph,
layout=layout_as_bipartite)
# graph color
colo <- c("#f9c74f","#f94144", "#4d908e", "#277da1", "#90be6d", "#00916e", "#766153")
V(modules_graph)$pie.color=list(colo)
par(mar=c(0,0,0,0))
plot(modules_graph,
layout=layout_as_bipartite)
plot(modules_graph,
layout=layout_as_bipartite,
vertex.shape="pie",
vertex.pie=module_pie_list,
#vertex.size=modules_size$n *10,
edge.curved=.1,
#edge.color="white",
vertex.label=NA)
View(modules_size)
View(node_type)
View(modules_pie)
?rarecurve
data <- read_csv("Site3_Fuerteventura1.csv")
View(data)
# reading the ML results files
test_set <- read_csv("link_prediction/test_set.csv")
View(test_set)
library(caret)
library(yardstick)
# reading the ML results files
test_set <- read_csv("link_prediction/test_set.csv")
feature_importance <- read_csv("link_prediction/feature_importance.csv")
# setting a threshold for prediction
th <- 0.5
test_set_predict <- test_set %>%
select(y_true, y_proba) %>%
mutate(y_proba_th = ifelse(y_proba >= th, 1, 0)) %>%
mutate(predict = ifelse(y_true == y_proba_th, 1, 0)) %>%
mutate(y_proba_th = factor(y_proba_th, levels = c(1,0)), y_true = factor(y_true, levels = c(1,0)))
cat('## Metrics','\n','\n')
conf_matrix <- caret::confusionMatrix(data=test_set_predict$y_proba_th, reference = test_set_predict$y_true, dnn = c("Prediction", "Reference"))
print(knitr::kable(conf_matrix$table))
cat('\n','\n')
accuracy <- conf_matrix$overall['Accuracy']
cat("Accuracy: ", round(accuracy, 4), '\n')
precision <- conf_matrix$byClass['Precision']
cat("Precision: ", round(precision, 4), '\n')
recall <- conf_matrix$byClass['Sensitivity']
cat("Recall: ", round(recall, 4), '\n')
f1_score <- 2 * (precision * recall) / (precision + recall)
cat("F1_score: ", round(f1_score, 4), '\n','\n')
cat('## ROC curve','\n','\n')
auc_roc_score <- yardstick::roc_auc(test_set_predict, y_true, y_proba)
roc_obj <- yardstick::roc_curve(test_set_predict, y_true, y_proba) %>%
ggplot(aes(x = 1 - specificity, y = sensitivity)) +
geom_path(color = "blue") +
geom_abline(lty = 3) +
coord_equal() +
theme_bw() +
theme(plot.title = element_text(hjust = 0.5), plot.subtitle = element_text(hjust = 0.5))+
labs(title = "ROC Curve", subtitle = paste("AUC = ", round(auc_roc_score$.estimate,3)))
print(roc_obj)
cat('\n','\n')
cat('## Precision-Recall curve','\n','\n')
auc_pr_score <- yardstick::pr_auc(test_set_predict, y_true, y_proba)
pr_obj <- yardstick::pr_curve(test_set_predict, y_true, y_proba) %>%
ggplot(aes(x = recall, y = precision)) +
geom_path(color = "blue") +
coord_equal() +
theme_bw() +
theme(plot.title = element_text(hjust = 0.5), plot.subtitle = element_text(hjust = 0.5))+
labs(title = "Precision-Recall curve", subtitle = paste("AUC = ", round(auc_pr_score$.estimate,3)))
print(pr_obj)
cat('\n','\n')
cat('## Features importance','\n','\n')
feature_imp_g <- feature_importance %>%
arrange(value) %>%
mutate(feature = factor(feature, levels = feature)) %>%
ggplot(aes(x=feature, y=value)) +
geom_bar(stat = "identity") +
coord_flip()+
theme_bw() +
theme(axis.text = element_text(size = 14, color = 'black'), title = element_text(size = 20),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank()) +
labs(x="", y="Importance")
print(feature_imp_g)
cat('\n','\n')
feature_imp_g <- feature_importance %>%
arrange(value) %>%
mutate(feature = factor(feature, levels = feature)) %>%
ggplot(aes(x=feature, y=value)) +
geom_bar(stat = "identity") +
coord_flip()+
scale_x_continuous(limits = c(0, 1)) +
theme_bw() +
theme(axis.text = element_text(size = 14, color = 'black'), title = element_text(size = 20),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank()) +
labs(x="", y="Importance")
print(feature_imp_g)
View(feature_importance)
feature_imp_g <- feature_importance %>%
arrange(value) %>%
mutate(feature = factor(feature, levels = feature)) %>%
ggplot(aes(x=feature, y=value)) +
geom_bar(stat = "identity") +
coord_flip()+
scale_y_continuous(limits = c(0, 1)) +
theme_bw() +
theme(axis.text = element_text(size = 14, color = 'black'), title = element_text(size = 20),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank()) +
labs(x="", y="Importance")
print(feature_imp_g)
library(caret)
library(yardstick)
# reading the ML results files
test_set <- read_csv("link_prediction/test_set.csv")
feature_importance <- read_csv("link_prediction/feature_importance.csv")
# setting a threshold for prediction
th <- 0.5
test_set_predict <- test_set %>%
select(y_true, y_proba) %>%
mutate(y_proba_th = ifelse(y_proba >= th, 1, 0)) %>%
mutate(predict = ifelse(y_true == y_proba_th, 1, 0)) %>%
mutate(y_proba_th = factor(y_proba_th, levels = c(1,0)), y_true = factor(y_true, levels = c(1,0)))
cat('## Metrics','\n','\n')
conf_matrix <- caret::confusionMatrix(data=test_set_predict$y_proba_th, reference = test_set_predict$y_true, dnn = c("Prediction", "Reference"))
print(knitr::kable(conf_matrix$table))
cat('\n','\n')
accuracy <- conf_matrix$overall['Accuracy']
cat("Accuracy: ", round(accuracy, 4), '\n')
precision <- conf_matrix$byClass['Precision']
cat("Precision: ", round(precision, 4), '\n')
recall <- conf_matrix$byClass['Sensitivity']
cat("Recall: ", round(recall, 4), '\n')
f1_score <- 2 * (precision * recall) / (precision + recall)
cat("F1_score: ", round(f1_score, 4), '\n','\n')
cat('## ROC curve','\n','\n')
auc_roc_score <- yardstick::roc_auc(test_set_predict, y_true, y_proba)
roc_obj <- yardstick::roc_curve(test_set_predict, y_true, y_proba) %>%
ggplot(aes(x = 1 - specificity, y = sensitivity)) +
geom_path(color = "blue") +
geom_abline(lty = 3) +
coord_equal() +
theme_bw() +
theme(plot.title = element_text(hjust = 0.5), plot.subtitle = element_text(hjust = 0.5))+
labs(title = "ROC Curve", subtitle = paste("AUC = ", round(auc_roc_score$.estimate,3)))
print(roc_obj)
cat('\n','\n')
cat('## Precision-Recall curve','\n','\n')
auc_pr_score <- yardstick::pr_auc(test_set_predict, y_true, y_proba)
pr_obj <- yardstick::pr_curve(test_set_predict, y_true, y_proba) %>%
ggplot(aes(x = recall, y = precision)) +
geom_path(color = "blue") +
coord_equal() +
theme_bw() +
theme(plot.title = element_text(hjust = 0.5), plot.subtitle = element_text(hjust = 0.5))+
labs(title = "Precision-Recall curve", subtitle = paste("AUC = ", round(auc_pr_score$.estimate,3)))
print(pr_obj)
cat('\n','\n')
cat('## Features importance','\n','\n')
feature_imp_g <- feature_importance %>%
arrange(value) %>%
mutate(feature = factor(feature, levels = feature)) %>%
ggplot(aes(x=feature, y=value)) +
geom_bar(stat = "identity") +
coord_flip()+
scale_y_continuous(limits = c(0, 1)) +
theme_bw() +
theme(axis.text = element_text(size = 14, color = 'black'), title = element_text(size = 20),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank()) +
labs(x="", y="Importance")
print(feature_imp_g)
cat('\n','\n')
rm(list=ls())
# small mammals (hosts)
data_mammals <- read_csv("data/data_raw/data_small_mammals/Terrestrial_Mammals.csv")
data_mammals %<>% mutate(host_ID = as.numeric(gsub(".*?([0-9]+).*", "\\1", animal_id))) %>%
select(host_ID, elevation.obs, sex, mass, age_repro) %>%
mutate(sex = as.factor(sex), age_repro = as.factor(age_repro))
# microbiome
data_asv <- read_csv("data/data_processed/microbiome/data_asv_rra0.01_th1000.csv")
data_asv_filtered <- data_asv %>%
filter(host_species == "Rattus rattus" & village == "Mandena" & grid != "village") %>%
select(host_ID, asv_ID, grid, season) %>%
left_join(data_mammals, by="host_ID") %>%
mutate(season = factor(season))
# asv_degree
asv_degree <- data_asv_filtered %>%
group_by(asv_ID) %>%
summarise(n = n_distinct(host_ID))
data_asv_filtered %<>% left_join(asv_degree, by="asv_ID") %>%
#filter(n>1) %>%
select(-n)
grid_attributes <- read_csv("data/data_processed/village_attributes.csv") %>%
rename(grid=grid_name) %>%
filter(village == "Mandena")
grid_attr_pca <- prcomp(grid_attributes[3:10], scale=TRUE)
# taking the value of pca1
attr_pca1 <- grid_attr_pca$x[,1]
grid_attributes %<>% mutate(pca_grid_attr = attr_pca1) %>%
select(grid, pca_grid_attr)
#####################################################
# PCA for small mammals community
data_mammals_full <- read_csv("data/data_raw/data_small_mammals/Terrestrial_Mammals.csv")
data_mammals_full_mat <- data_mammals_full %>%
filter(grepl("TMR", animal_id)) %>%
rename(host_species = field_identification, grid = habitat_type) %>%
filter(host_species != "Rattus rattus", grid != "village") %>%
select(host_species, grid) %>%
count(grid, host_species) %>%
spread(host_species, n, fill = 0)
grid_sm_pca <- prcomp(data_mammals_full_mat[-1], scale=TRUE)
# taking the value of pca1
sm_pca1 <- grid_sm_pca$x[,1]
data_mammals_full_mat %<>% mutate(pca_grid_sm = sm_pca1) %>%
select(grid, pca_grid_sm)
final_table <- data_asv_filtered %>%
mutate(link = 1) %>%
spread(asv_ID, link, fill = 0)  %>%
gather("asv_ID","Link", starts_with("ASV")) %>%
left_join(grid_attributes, by="grid") %>%
left_join(data_mammals_full_mat, by="grid")
View(final_table)
# centrality
node_centrality <- bipartite::specieslevel(data_asv_mat, index = c("degree"))
# transforming to matrix
data_asv_mat <- data_asv_filtered %>% select(host_ID, asv_ID) %>%
mutate(reads = 1) %>%
spread(asv_ID, reads, fill = 0) %>%
column_to_rownames("host_ID") %>%
as.matrix()
# centrality
node_centrality <- bipartite::specieslevel(data_asv_mat, index = c("degree"))
asv_centrality <- node_centrality$`higher level` %>%
select(degree, betweenness, closeness) %>%
rename(asv_degree=degree, asv_betweenness=betweenness, asv_closeness=closeness) %>%
rownames_to_column("asv_ID")
asv_centrality <- node_centrality$`higher level` %>%
select(degree, betweenness, closeness) %>%
rename(asv_degree=degree) %>%
rownames_to_column("asv_ID")
# centrality
node_centrality <- bipartite::specieslevel(data_asv_mat, index = c("degree", "betweenness", "closeness"))
asv_centrality <- node_centrality$`higher level` %>%
select(degree, betweenness, closeness) %>%
rename(asv_degree=degree, asv_betweenness=betweenness, asv_closeness=closeness) %>%
rownames_to_column("asv_ID")
host_centrality <- node_centrality$`lower level` %>%
select(degree, betweenness, closeness) %>%
rename(host_degree=degree, host_betweenness=betweenness, host_closeness=closeness) %>%
rownames_to_column("host_ID") %>% mutate(host_ID = as.double(host_ID))
asv_taxa <- read_delim("data/data_raw/data_microbiome/ASVs_all_merged_taxonomy.tsv") %>%
select(ASV, Phylum, Class)
View(asv_taxa)
final_table <- data_asv_filtered %>%
mutate(link = 1) %>%
spread(asv_ID, link, fill = 0)  %>%
gather("asv_ID","Link", starts_with("ASV")) %>%
left_join(grid_attributes, by="grid") %>%
left_join(data_mammals_full_mat, by="grid") %>%
left_join(asv_taxa, by=c("asv_ID"="ASV")) %>%
left_join(host_centrality, by="host_ID") %>%
left_join(asv_centrality, by="asv_ID")
# saving the final table as .csv
write_csv(final_table, "ML_rattus_mandena_include_degree1.csv")
library(caret)
library(yardstick)
# reading the ML results files
test_set <- read_csv("link_prediction/test_set_degree1.csv")
feature_importance <- read_csv("link_prediction/feature_importance_degree1.csv")
# setting a threshold for prediction
th <- 0.5
test_set_predict <- test_set %>%
select(y_true, y_proba) %>%
mutate(y_proba_th = ifelse(y_proba >= th, 1, 0)) %>%
mutate(predict = ifelse(y_true == y_proba_th, 1, 0)) %>%
mutate(y_proba_th = factor(y_proba_th, levels = c(1,0)), y_true = factor(y_true, levels = c(1,0)))
cat('## Metrics','\n','\n')
conf_matrix <- caret::confusionMatrix(data=test_set_predict$y_proba_th, reference = test_set_predict$y_true, dnn = c("Prediction", "Reference"))
print(knitr::kable(conf_matrix$table))
cat('\n','\n')
accuracy <- conf_matrix$overall['Accuracy']
cat("Accuracy: ", round(accuracy, 4), '\n')
precision <- conf_matrix$byClass['Precision']
cat("Precision: ", round(precision, 4), '\n')
recall <- conf_matrix$byClass['Sensitivity']
cat("Recall: ", round(recall, 4), '\n')
f1_score <- 2 * (precision * recall) / (precision + recall)
cat("F1_score: ", round(f1_score, 4), '\n','\n')
cat('## ROC curve','\n','\n')
auc_roc_score <- yardstick::roc_auc(test_set_predict, y_true, y_proba)
roc_obj <- yardstick::roc_curve(test_set_predict, y_true, y_proba) %>%
ggplot(aes(x = 1 - specificity, y = sensitivity)) +
geom_path(color = "blue") +
geom_abline(lty = 3) +
coord_equal() +
theme_bw() +
theme(plot.title = element_text(hjust = 0.5), plot.subtitle = element_text(hjust = 0.5))+
labs(title = "ROC Curve", subtitle = paste("AUC = ", round(auc_roc_score$.estimate,3)))
print(roc_obj)
cat('\n','\n')
cat('## Precision-Recall curve','\n','\n')
auc_pr_score <- yardstick::pr_auc(test_set_predict, y_true, y_proba)
pr_obj <- yardstick::pr_curve(test_set_predict, y_true, y_proba) %>%
ggplot(aes(x = recall, y = precision)) +
geom_path(color = "blue") +
coord_equal() +
theme_bw() +
theme(plot.title = element_text(hjust = 0.5), plot.subtitle = element_text(hjust = 0.5))+
labs(title = "Precision-Recall curve", subtitle = paste("AUC = ", round(auc_pr_score$.estimate,3)))
print(pr_obj)
cat('\n','\n')
cat('## Features importance','\n','\n')
feature_imp_g <- feature_importance %>%
arrange(value) %>%
mutate(feature = factor(feature, levels = feature)) %>%
ggplot(aes(x=feature, y=value)) +
geom_bar(stat = "identity") +
coord_flip()+
scale_y_continuous(limits = c(0, 1)) +
theme_bw() +
theme(axis.text = element_text(size = 14, color = 'black'), title = element_text(size = 20),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank()) +
labs(x="", y="Importance")
print(feature_imp_g)
cat('\n','\n')
library(caret)
library(yardstick)
# reading the ML results files
test_set <- read_csv("link_prediction/test_set.csv")
feature_importance <- read_csv("link_prediction/feature_importance.csv")
# setting a threshold for prediction
th <- 0.5
test_set_predict <- test_set %>%
select(y_true, y_proba) %>%
mutate(y_proba_th = ifelse(y_proba >= th, 1, 0)) %>%
mutate(predict = ifelse(y_true == y_proba_th, 1, 0)) %>%
mutate(y_proba_th = factor(y_proba_th, levels = c(1,0)), y_true = factor(y_true, levels = c(1,0)))
cat('## Metrics','\n','\n')
conf_matrix <- caret::confusionMatrix(data=test_set_predict$y_proba_th, reference = test_set_predict$y_true, dnn = c("Prediction", "Reference"))
print(knitr::kable(conf_matrix$table))
cat('\n','\n')
accuracy <- conf_matrix$overall['Accuracy']
cat("Accuracy: ", round(accuracy, 4), '\n')
precision <- conf_matrix$byClass['Precision']
cat("Precision: ", round(precision, 4), '\n')
recall <- conf_matrix$byClass['Sensitivity']
cat("Recall: ", round(recall, 4), '\n')
f1_score <- 2 * (precision * recall) / (precision + recall)
cat("F1_score: ", round(f1_score, 4), '\n','\n')
cat('## ROC curve','\n','\n')
auc_roc_score <- yardstick::roc_auc(test_set_predict, y_true, y_proba)
roc_obj <- yardstick::roc_curve(test_set_predict, y_true, y_proba) %>%
ggplot(aes(x = 1 - specificity, y = sensitivity)) +
geom_path(color = "blue") +
geom_abline(lty = 3) +
coord_equal() +
theme_bw() +
theme(plot.title = element_text(hjust = 0.5), plot.subtitle = element_text(hjust = 0.5))+
labs(title = "ROC Curve", subtitle = paste("AUC = ", round(auc_roc_score$.estimate,3)))
print(roc_obj)
cat('\n','\n')
cat('## Precision-Recall curve','\n','\n')
auc_pr_score <- yardstick::pr_auc(test_set_predict, y_true, y_proba)
pr_obj <- yardstick::pr_curve(test_set_predict, y_true, y_proba) %>%
ggplot(aes(x = recall, y = precision)) +
geom_path(color = "blue") +
coord_equal() +
theme_bw() +
theme(plot.title = element_text(hjust = 0.5), plot.subtitle = element_text(hjust = 0.5))+
labs(title = "Precision-Recall curve", subtitle = paste("AUC = ", round(auc_pr_score$.estimate,3)))
print(pr_obj)
cat('\n','\n')
cat('## Features importance','\n','\n')
feature_imp_g <- feature_importance %>%
arrange(value) %>%
mutate(feature = factor(feature, levels = feature)) %>%
ggplot(aes(x=feature, y=value)) +
geom_bar(stat = "identity") +
coord_flip()+
scale_y_continuous(limits = c(0, 1)) +
theme_bw() +
theme(axis.text = element_text(size = 14, color = 'black'), title = element_text(size = 20),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank()) +
labs(x="", y="Importance")
print(feature_imp_g)
cat('\n','\n')
unlink("code/main_script_cache", recursive = TRUE)
knitr::opts_chunk$set(results = "asis", message=FALSE, warning=FALSE, cache=TRUE, eval = TRUE, dev = c('png'), out.width = '100%', out.height='60%')
source("modularity_analysis_functions.R", local = knitr::knit_global())
