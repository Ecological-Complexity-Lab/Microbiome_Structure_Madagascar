for (v in village_names) {
data_asv_village <- data_asv %>%
filter(village == v)
# calculating ASVs degree
asv_degree <- data_asv_village %>%
group_by(asv_ID) %>%
summarise(n = n_distinct(host_ID)) %>%
rename(asv_degree = n)
data_asv_village %<>% left_join(asv_degree, by="asv_ID")
##### observed network
# finding modules
modules_observed <- fun_modularity_analysis(data_asv_village)
modules_table_three_villages <- rbind(modules_table_three_villages, modules_observed)
# calculating similarity in modules between grids
modules_similarity <- fun_modules_similarity(modules_observed) %>%
mutate(village = v)
# saving results in one table
modules_similarity_three_villages <- rbind(modules_similarity_three_villages, modules_similarity)
# ASVs degree distribution
asv_degree_distribution <- fun_asv_degree_distribution(data_asv_village)
asv_degree_distribution_three_villages <- append(asv_degree_distribution_three_villages, asv_degree_distribution)
# figure of modules
modules <- fun_modules(modules_observed)
modules_three_villages <- append(modules_three_villages, modules)
# modules size
modules_size <- fun_module_size(modules_observed)
modules_size_three_villages <- append(modules_size_three_villages, modules_size)
# Number of land uses per module
modules_grid <- fun_module_grid(modules_observed)
modules_grid_three_villages <- append(modules_grid_three_villages, modules_grid)
# calculating NMI
nmi_observed <- fun_nmi_calc(modules_observed, TRUE)
# saving results in one list
nmi_observed_three_villages <- append(nmi_observed_three_villages, nmi_observed)
##### NMI for different values of core microbiome
# calling the function
nmi_diff_core <- fun_modularity_diff_core(data_asv_village, nmi_observed, core_seq)
# saving results in one list
nmi_diff_core_three_villages <- append(nmi_diff_core_three_villages, nmi_diff_core)
}
# loop for three villages
for (j in 1:3) {
cat('###',village_names[j],'{.tabset}','\n','\n')
cat('#### NMI','\n')
print(nmi_observed_three_villages[[j*2]])
cat('\n','\n')
cat('#### NMI for core/non-core','\n')
print(nmi_diff_core_three_villages[[j]])
cat('\n','\n')
}
source("modularity_analysis_functions.R", local = knitr::knit_global())
# reading the microbiome data
# working only with Rattus from the three villages
# removing the 'village' grid from the analysis
data_asv <- read_csv("../data/data_processed/microbiome/data_asv_rra0.01_th1000.csv") %>%
filter(host_species == "Rattus rattus" & grid!="village")
# # ASVs taxonomy
# asv_taxa <- read_delim("../data/data_raw/data_microbiome/ASVs_all_merged_taxonomy.tsv") %>%
#   select(ASV, Family)
# data_asv %<>% left_join(asv_taxa, by=c("asv_ID"="ASV"))
#
# data_asv_family <- data_asv %>%
#   group_by(host_ID, village, host_species, grid, season,total_reads, Family) %>%
#   summarise(reads = sum(reads)) %>%
#   rename(asv_ID = Family) %>%
#   filter(!(is.na(asv_ID)))
# data_asv <- data_asv_family
seq(1,20, by=4)
seq(1,20, by=3)
# first of all, run this chunk of code.
# this code does all the modularity analysis using the functions in "modularity_analysis_functions".
# There is a loop runs for the three villages, and all the analysis is done separately for each village.
# the output of the code is variables holding the final results figures (the output of the functions used)
# setting thresholds for core
core_seq <- seq(1,20, by=3)
village_names <- unique(data_asv$village)
nmi_observed_three_villages <- NULL
nmi_diff_core_three_villages <- NULL
modules_similarity_three_villages <- NULL
asv_degree_distribution_three_villages <- NULL
modules_three_villages <- NULL
modules_size_three_villages <- NULL
modules_grid_three_villages <- NULL
modules_table_three_villages <- NULL
# for loop for three villages
for (v in village_names) {
data_asv_village <- data_asv %>%
filter(village == v)
# calculating ASVs degree
asv_degree <- data_asv_village %>%
group_by(asv_ID) %>%
summarise(n = n_distinct(host_ID)) %>%
rename(asv_degree = n)
data_asv_village %<>% left_join(asv_degree, by="asv_ID")
##### observed network
# finding modules
modules_observed <- fun_modularity_analysis(data_asv_village)
modules_table_three_villages <- rbind(modules_table_three_villages, modules_observed)
# calculating similarity in modules between grids
modules_similarity <- fun_modules_similarity(modules_observed) %>%
mutate(village = v)
# saving results in one table
modules_similarity_three_villages <- rbind(modules_similarity_three_villages, modules_similarity)
# ASVs degree distribution
asv_degree_distribution <- fun_asv_degree_distribution(data_asv_village)
asv_degree_distribution_three_villages <- append(asv_degree_distribution_three_villages, asv_degree_distribution)
# figure of modules
modules <- fun_modules(modules_observed)
modules_three_villages <- append(modules_three_villages, modules)
# modules size
modules_size <- fun_module_size(modules_observed)
modules_size_three_villages <- append(modules_size_three_villages, modules_size)
# Number of land uses per module
modules_grid <- fun_module_grid(modules_observed)
modules_grid_three_villages <- append(modules_grid_three_villages, modules_grid)
# calculating NMI
nmi_observed <- fun_nmi_calc(modules_observed, TRUE)
# saving results in one list
nmi_observed_three_villages <- append(nmi_observed_three_villages, nmi_observed)
##### NMI for different values of core microbiome
# calling the function
nmi_diff_core <- fun_modularity_diff_core(data_asv_village, nmi_observed, core_seq)
# saving results in one list
nmi_diff_core_three_villages <- append(nmi_diff_core_three_villages, nmi_diff_core)
}
# loop for three villages
for (j in 1:3) {
cat('###',village_names[j],'{.tabset}','\n','\n')
cat('#### NMI','\n')
print(nmi_observed_three_villages[[j*2]])
cat('\n','\n')
cat('#### NMI for core/non-core','\n')
print(nmi_diff_core_three_villages[[j]])
cat('\n','\n')
}
source("modularity_analysis_functions.R", local = knitr::knit_global())
# reading the microbiome data
# working only with Rattus from the three villages
# removing the 'village' grid from the analysis
data_asv <- read_csv("../data/data_processed/microbiome/data_asv_rra0.01_th1000.csv") %>%
filter(host_species == "Rattus rattus" & grid!="village")
# # ASVs taxonomy
# asv_taxa <- read_delim("../data/data_raw/data_microbiome/ASVs_all_merged_taxonomy.tsv") %>%
#   select(ASV, Family)
# data_asv %<>% left_join(asv_taxa, by=c("asv_ID"="ASV"))
#
# data_asv_family <- data_asv %>%
#   group_by(host_ID, village, host_species, grid, season,total_reads, Family) %>%
#   summarise(reads = sum(reads)) %>%
#   rename(asv_ID = Family) %>%
#   filter(!(is.na(asv_ID)))
# data_asv <- data_asv_family
# first of all, run this chunk of code.
# this code does all the modularity analysis using the functions in "modularity_analysis_functions".
# There is a loop runs for the three villages, and all the analysis is done separately for each village.
# the output of the code is variables holding the final results figures (the output of the functions used)
# setting thresholds for core
core_seq <- seq(1,20, by=2)
village_names <- unique(data_asv$village)
nmi_observed_three_villages <- NULL
nmi_diff_core_three_villages <- NULL
modules_similarity_three_villages <- NULL
asv_degree_distribution_three_villages <- NULL
modules_three_villages <- NULL
modules_size_three_villages <- NULL
modules_grid_three_villages <- NULL
modules_table_three_villages <- NULL
# for loop for three villages
for (v in village_names) {
data_asv_village <- data_asv %>%
filter(village == v)
# calculating ASVs degree
asv_degree <- data_asv_village %>%
group_by(asv_ID) %>%
summarise(n = n_distinct(host_ID)) %>%
rename(asv_degree = n)
data_asv_village %<>% left_join(asv_degree, by="asv_ID")
##### observed network
# finding modules
modules_observed <- fun_modularity_analysis(data_asv_village)
modules_table_three_villages <- rbind(modules_table_three_villages, modules_observed)
# calculating similarity in modules between grids
modules_similarity <- fun_modules_similarity(modules_observed) %>%
mutate(village = v)
# saving results in one table
modules_similarity_three_villages <- rbind(modules_similarity_three_villages, modules_similarity)
# ASVs degree distribution
asv_degree_distribution <- fun_asv_degree_distribution(data_asv_village)
asv_degree_distribution_three_villages <- append(asv_degree_distribution_three_villages, asv_degree_distribution)
# figure of modules
modules <- fun_modules(modules_observed)
modules_three_villages <- append(modules_three_villages, modules)
# modules size
modules_size <- fun_module_size(modules_observed)
modules_size_three_villages <- append(modules_size_three_villages, modules_size)
# Number of land uses per module
modules_grid <- fun_module_grid(modules_observed)
modules_grid_three_villages <- append(modules_grid_three_villages, modules_grid)
# calculating NMI
nmi_observed <- fun_nmi_calc(modules_observed, TRUE)
# saving results in one list
nmi_observed_three_villages <- append(nmi_observed_three_villages, nmi_observed)
##### NMI for different values of core microbiome
# calling the function
nmi_diff_core <- fun_modularity_diff_core(data_asv_village, nmi_observed, core_seq)
# saving results in one list
nmi_diff_core_three_villages <- append(nmi_diff_core_three_villages, nmi_diff_core)
}
# loop for three villages
for (j in 1:3) {
cat('###',village_names[j],'{.tabset}','\n','\n')
cat('#### NMI','\n')
print(nmi_observed_three_villages[[j*2]])
cat('\n','\n')
cat('#### NMI for core/non-core','\n')
print(nmi_diff_core_three_villages[[j]])
cat('\n','\n')
}
seq(1,20, by=2)
dat=data_asv_village
i=10
# filtering out ASVs with lower degree than the threshold
data_asv_filtered_noncore <- dat %>% filter(asv_degree <= j)
# modularity
modules <- fun_modularity_analysis(data_asv_filtered_noncore)
# NMI
nmi_mid <- fun_nmi_calc(modules, FALSE)
nmi_mid <- nmi_mid[[1]] %>%
mutate(degree = j, type = "non-core", sig = ifelse(p <= 0.05, 1, 0), n_asv = length(unique(data_asv_filtered_core$asv_ID)))
# filtering out ASVs with lower degree than the threshold
data_asv_filtered_core <- dat %>% filter(asv_degree >= i)
# modularity
modules <- fun_modularity_analysis(data_asv_filtered_core)
# NMI
nmi_mid <- fun_nmi_calc(modules, FALSE)
nmi_mid <- nmi_mid[[1]] %>%
mutate(degree = i, type = "core", sig = ifelse(p <= 0.05, 1, 0), n_asv = length(unique(data_asv_filtered_core$asv_ID)))
View(nmi_mid)
dat=modules
hosts <- dat %>% ungroup() %>% distinct(host_ID, grid, host_group)
nmi_obs <- aricode::NMI(hosts$grid, hosts$host_group, "sum")
nmi_shuff <- vector(length = 1000)
for(i in 1:1000) {
# shuffling the grid attribute
hosts_shuff <- hosts %>%
mutate(grid = sample(grid,nrow(hosts)))
# calculating nmi
nmi_shuff[i] <- aricode::NMI(hosts_shuff$grid, hosts_shuff$host_group, "sum")
}
# calculating p value
p <- length(nmi_shuff[nmi_shuff>=nmi_obs]) / length(nmi_shuff)
source("modularity_analysis_functions.R", local = knitr::knit_global())
# reading the microbiome data
# working only with Rattus from the three villages
# removing the 'village' grid from the analysis
data_asv <- read_csv("../data/data_processed/microbiome/data_asv_rra0.01_th1000.csv") %>%
filter(host_species == "Rattus rattus" & grid!="village")
# # ASVs taxonomy
# asv_taxa <- read_delim("../data/data_raw/data_microbiome/ASVs_all_merged_taxonomy.tsv") %>%
#   select(ASV, Family)
# data_asv %<>% left_join(asv_taxa, by=c("asv_ID"="ASV"))
#
# data_asv_family <- data_asv %>%
#   group_by(host_ID, village, host_species, grid, season,total_reads, Family) %>%
#   summarise(reads = sum(reads)) %>%
#   rename(asv_ID = Family) %>%
#   filter(!(is.na(asv_ID)))
# data_asv <- data_asv_family
# first of all, run this chunk of code.
# this code does all the modularity analysis using the functions in "modularity_analysis_functions".
# There is a loop runs for the three villages, and all the analysis is done separately for each village.
# the output of the code is variables holding the final results figures (the output of the functions used)
# setting thresholds for core
core_seq <- seq(1,20, by=2)
village_names <- unique(data_asv$village)
nmi_observed_three_villages <- NULL
nmi_diff_core_three_villages <- NULL
modules_similarity_three_villages <- NULL
asv_degree_distribution_three_villages <- NULL
modules_three_villages <- NULL
modules_size_three_villages <- NULL
modules_grid_three_villages <- NULL
modules_table_three_villages <- NULL
# for loop for three villages
for (v in village_names) {
data_asv_village <- data_asv %>%
filter(village == v)
# calculating ASVs degree
asv_degree <- data_asv_village %>%
group_by(asv_ID) %>%
summarise(n = n_distinct(host_ID)) %>%
rename(asv_degree = n)
data_asv_village %<>% left_join(asv_degree, by="asv_ID")
##### observed network
# finding modules
modules_observed <- fun_modularity_analysis(data_asv_village)
modules_table_three_villages <- rbind(modules_table_three_villages, modules_observed)
# calculating similarity in modules between grids
modules_similarity <- fun_modules_similarity(modules_observed) %>%
mutate(village = v)
# saving results in one table
modules_similarity_three_villages <- rbind(modules_similarity_three_villages, modules_similarity)
# ASVs degree distribution
asv_degree_distribution <- fun_asv_degree_distribution(data_asv_village)
asv_degree_distribution_three_villages <- append(asv_degree_distribution_three_villages, asv_degree_distribution)
# figure of modules
modules <- fun_modules(modules_observed)
modules_three_villages <- append(modules_three_villages, modules)
# modules size
modules_size <- fun_module_size(modules_observed)
modules_size_three_villages <- append(modules_size_three_villages, modules_size)
# Number of land uses per module
modules_grid <- fun_module_grid(modules_observed)
modules_grid_three_villages <- append(modules_grid_three_villages, modules_grid)
# calculating NMI
nmi_observed <- fun_nmi_calc(modules_observed, TRUE)
# saving results in one list
nmi_observed_three_villages <- append(nmi_observed_three_villages, nmi_observed)
##### NMI for different values of core microbiome
# calling the function
nmi_diff_core <- fun_modularity_diff_core(data_asv_village, nmi_observed, core_seq)
# saving results in one list
nmi_diff_core_three_villages <- append(nmi_diff_core_three_villages, nmi_diff_core)
}
# loop for three villages
for (j in 1:3) {
cat('###',village_names[j],'{.tabset}','\n','\n')
cat('#### NMI','\n')
print(nmi_observed_three_villages[[j*2]])
cat('\n','\n')
cat('#### NMI for core/non-core','\n')
print(nmi_diff_core_three_villages[[j]])
cat('\n','\n')
}
# Model
library("glmmTMB")
?glmmTMB
full_model <- glmmTMB(module_similarity ~ grid_attr + grid_dist + sm_community + (1|services), family=beta_family(link="logit"), data = final_data, na.action = na.fail)
# reading grid similarity results
grids_similarity_attr <- read_csv("../data/data_processed/village_summary2.csv")
# combining the variables
final_data <- modules_similarity_three_villages %>%
left_join(grids_similarity_attr, by=c("village","grid1","grid2")) %>%
filter(grid1!="village") # removing the village grid
# saving the final table
#write_csv(final_data, "data/data_processed/final_modularity_data.csv")
full_model <- glmmTMB(module_similarity ~ grid_attr + grid_dist + sm_community + (1|services), family=beta_family(link="logit"), data = final_data, na.action = na.fail)
full_model <- glmmTMB(module_similarity ~ grid_attr + grid_dist + sm_community + (1|village), family=beta_family(link="logit"), data = final_data, na.action = na.fail)
full_model <- glmmTMB(module_similarity ~ grid_attr + grid_dist + sm_community , family=beta_family(link="logit"), data = final_data, na.action = na.fail)
Anova(full_model)
summary(full_model)
View(final_data)
full_model <- glmmTMB(module_similarity ~ grid_attr + grid_dist + sm_community, family=beta_family(link="logit"), data = final_data, na.action = na.fail)
#Homogeneity
EM<-resid(full_model, type= "response")
FM<-fitted(full_model)
plot(x=FM, y=EM, xlab = "Ajustados", ylab = "Residuales normalizados")
abline(0,0, col="red", lwd= 3)
plot(x=FM, y=EM, xlab = "Ajustados", ylab = "Residuales normalizados")
plot(x=FM, y=EM, xlab = "Ajustados", ylab = "Residuales normalizados")
print(knitr::kable(car::vif(full_model)))
?vif
dredge_modules_similarity <- MuMIn::dredge(full_model)
# The best models: delta <= 5
results_modules_similarity <- subset(dredge_modules_similarity, delta <= 5 | df == 3 | df == max(df), recalc.weights = FALSE)
row.names(results_modules_similarity) <- c(1:(nrow(results_modules_similarity)))
# arranging the final table
aic_results_final <- as.data.frame(results_modules_similarity) %>%
select(-df, -logLik) %>%
dplyr::rename(intercept='(Intercept)', grid_attributes=grid_attr, grid_distance=grid_dist, sm_similarity=sm_community) %>%
mutate(across(everything()), round(.,3))
View(results_modules_similarity)
?dredge
full_model <- glmmTMB(module_similarity ~ grid_attr + grid_dist + sm_community, family=beta_family(link="logit"), data = final_data, na.action = na.fail)
model1 <- glmmTMB(module_similarity ~ grid_dist + sm_community +(1|village), family=beta_family(link="logit"), data = final_data, na.action = na.fail)
model2 <- glmmTMB(module_similarity ~ grid_attr +  sm_community+(1|village), family=beta_family(link="logit"), data = final_data, na.action = na.fail)
model3 <- glmmTMB(module_similarity ~ grid_attr + grid_dist +(1|village), family=beta_family(link="logit"), data = final_data, na.action = na.fail)
model4  <- glmmTMB(module_similarity ~ grid_attr +(1|village), family=beta_family(link="logit"), data = final_data, na.action = na.fail)
model5 <- glmmTMB(module_similarity ~  grid_dist +(1|village), family=beta_family(link="logit"), data = final_data, na.action = na.fail)
str(full_model)
str(final_data)
# reading grid similarity results
grids_similarity_attr <- read_csv("../data/data_processed/village_summary2.csv")
# combining the variables
final_data <- modules_similarity_three_villages %>%
left_join(grids_similarity_attr, by=c("village","grid1","grid2")) %>%
mutate(village = as.factor(village)) %>%
filter(grid1!="village") # removing the village grid
# saving the final table
#write_csv(final_data, "data/data_processed/final_modularity_data.csv")
model1 <- glmmTMB(module_similarity ~ grid_dist + sm_community +(1|village), family=beta_family(link="logit"), data = final_data, na.action = na.fail)
model6  <- glmmTMB(module_similarity ~  sm_community +(1|village), family=beta_family(link="logit"), data = final_data, na.action = na.fail)
str(final_data)
full_model <- glmmTMB(module_similarity ~ grid_attr + grid_dist + sm_community + village, family=beta_family(link="logit"), data = final_data, na.action = na.fail)
# AIC
library(MuMIn)
dredge_modules_similarity <- MuMIn::dredge(full_model)
# The best models: delta <= 5
results_modules_similarity <- subset(dredge_modules_similarity, delta <= 5 | df == 3 | df == max(df), recalc.weights = FALSE)
row.names(results_modules_similarity) <- c(1:(nrow(results_modules_similarity)))
?AICc
?AIC
?mrm
# setting the full model
library(nlme)
full_model <- lme(module_similarity ~ grid_attr + grid_dist + sm_community, random=~1|village, data = final_data, method = "ML", na.action = na.fail)
# r.squaredGLMM(full_model)
qqnorm(residuals(full_model))
qqline(residuals(full_model))
qqnorm(residuals(full_model))
qqline(residuals(full_model))
hist(residuals(full_model))
plot(residuals(full_model) ~ fitted(full_model))
car::ncvTest(full_model)
shapiro.test(residuals(full_model))
full_model <- lme(module_similarity ~  sm_community, random=~1|village, data = final_data, method = "ML", na.action = na.fail)
# checking normality assumption
shapiro.test(residuals(full_model))
?anova
full_model <- lme(module_similarity ~ grid_attr + grid_dist + sm_community, random=~1|village, data = final_data, method = "ML", na.action = na.fail)
# r.squaredGLMM(full_model)
anova(full_model)
# r.squaredGLMM(full_model)
summary(anova(full_model))
# r.squaredGLMM(full_model)
summary(full_model)
r.squaredGLMM(full_model)
unlink("code/modularity_analysis_main_cache", recursive = TRUE)
?NMI
source("modularity_analysis_functions.R", local = knitr::knit_global())
# reading the microbiome data
# working only with Rattus from the three villages
# removing the 'village' grid from the analysis
data_asv <- read_csv("../data/data_processed/microbiome/data_asv_rra0.01_th1000.csv") %>%
filter(host_species == "Rattus rattus" & grid!="village")
# # ASVs taxonomy
# asv_taxa <- read_delim("../data/data_raw/data_microbiome/ASVs_all_merged_taxonomy.tsv") %>%
#   select(ASV, Family)
# data_asv %<>% left_join(asv_taxa, by=c("asv_ID"="ASV"))
#
# data_asv_family <- data_asv %>%
#   group_by(host_ID, village, host_species, grid, season,total_reads, Family) %>%
#   summarise(reads = sum(reads)) %>%
#   rename(asv_ID = Family) %>%
#   filter(!(is.na(asv_ID)))
# data_asv <- data_asv_family
# first of all, run this chunk of code.
# this code does all the modularity analysis using the functions in "modularity_analysis_functions".
# There is a loop runs for the three villages, and all the analysis is done separately for each village.
# the output of the code is variables holding the final results figures (the output of the functions used)
# setting thresholds for core
core_seq <- seq(1,20, by=1)
village_names <- unique(data_asv$village)
nmi_observed_three_villages <- NULL
nmi_diff_core_three_villages <- NULL
modules_similarity_three_villages <- NULL
asv_degree_distribution_three_villages <- NULL
modules_three_villages <- NULL
modules_size_three_villages <- NULL
modules_grid_three_villages <- NULL
modules_table_three_villages <- NULL
# for loop for three villages
for (v in village_names) {
data_asv_village <- data_asv %>%
filter(village == v)
# calculating ASVs degree
asv_degree <- data_asv_village %>%
group_by(asv_ID) %>%
summarise(n = n_distinct(host_ID)) %>%
rename(asv_degree = n)
data_asv_village %<>% left_join(asv_degree, by="asv_ID")
##### observed network
# finding modules
modules_observed <- fun_modularity_analysis(data_asv_village)
modules_table_three_villages <- rbind(modules_table_three_villages, modules_observed)
# calculating similarity in modules between grids
modules_similarity <- fun_modules_similarity(modules_observed) %>%
mutate(village = v)
# saving results in one table
modules_similarity_three_villages <- rbind(modules_similarity_three_villages, modules_similarity)
# ASVs degree distribution
asv_degree_distribution <- fun_asv_degree_distribution(data_asv_village)
asv_degree_distribution_three_villages <- append(asv_degree_distribution_three_villages, asv_degree_distribution)
# figure of modules
modules <- fun_modules(modules_observed)
modules_three_villages <- append(modules_three_villages, modules)
# modules size
modules_size <- fun_module_size(modules_observed)
modules_size_three_villages <- append(modules_size_three_villages, modules_size)
# Number of land uses per module
modules_grid <- fun_module_grid(modules_observed)
modules_grid_three_villages <- append(modules_grid_three_villages, modules_grid)
# calculating NMI
nmi_observed <- fun_nmi_calc(modules_observed, TRUE)
# saving results in one list
nmi_observed_three_villages <- append(nmi_observed_three_villages, nmi_observed)
##### NMI for different values of core microbiome
# calling the function
nmi_diff_core <- fun_modularity_diff_core(data_asv_village, nmi_observed, core_seq)
# saving results in one list
nmi_diff_core_three_villages <- append(nmi_diff_core_three_villages, nmi_diff_core)
}
# loop for three villages
for (j in 1:3) {
cat('###',village_names[j],'{.tabset}','\n','\n')
cat('#### NMI','\n')
print(nmi_observed_three_villages[[j*2]])
cat('\n','\n')
cat('#### NMI for core/non-core','\n')
print(nmi_diff_core_three_villages[[j]])
cat('\n','\n')
}
