<<<<<<< HEAD
nmi_diff_core <- fun_modularity_diff_core(data_asv_village, nmi_observed, core_seq) %>%
mutate(village = v)
# saving results in one list
nmi_diff_core_three_villages <- rbind(nmi_diff_core_three_villages, nmi_diff_core)
##### phylogenetic analysis
# ASVs pool
asv_pool <- data_asv_village %>%
distinct(asv_ID, asv_degree) %>%
mutate(p = asv_degree/length(unique(data_asv_village$asv_ID)))
# calculating betaNTI
data_betaNTI <- data_asv_village %>%
distinct(host_ID, asv_ID) %>%
mutate(reads = 1) %>%
spread(asv_ID, reads, fill = 0) %>%
column_to_rownames("host_ID") %>%
as.matrix()
betaNTI <- fun_calc_betaNTI(data_betaNTI, asv_distance, asv_pool) %>%
left_join(modules_observed %>% distinct(host_ID, host_group, grid), by=c("host1"="host_ID")) %>% rename(host_group1=host_group, grid1=grid) %>%
left_join(modules_observed %>% distinct(host_ID, host_group, grid), by=c("host2"="host_ID")) %>% rename(host_group2=host_group, grid2=grid) %>%
mutate(village = v)
betaNTI_three_villages <- rbind(betaNTI_three_villages, betaNTI)
# raup-crick
raupc <- raupcrick(data_betaNTI)
raupc2 <- as.matrix(raupc)
raupc2[upper.tri(raupc2)] <- NA
diag(raupc2) <- NA
raupc2_m <- melt(raupc2) %>%
filter(!(is.na(value)))%>%
rename(host1 = Var1, host2 = Var2, raupc = value) %>%
left_join(modules_observed %>% distinct(host_ID, host_group, grid), by=c("host1"="host_ID")) %>% rename(host_group1=host_group, grid1=grid) %>%
left_join(modules_observed %>% distinct(host_ID, host_group, grid), by=c("host2"="host_ID")) %>% rename(host_group2=host_group, grid2=grid) %>%
mutate(village = v)
raupc_three_villages <- rbind(raupc_three_villages, raupc2_m)
}
# loop for three villages
for (i in 1:3) {
cat('##',village_names[i],'{.tabset}','\n','\n')
cat('### ASVs degree distribution','\n')
print(asv_degree_distribution_three_villages[[i]])
cat('\n','\n')
# calculating connectance
connectance_data <- modules_table_three_villages %>%
filter(village == village_names[i])
cat('No. of hosts: ', length(unique(connectance_data$host_ID)) ,'\n','\n')
cat('No. of ASVs: ', length(unique(connectance_data$asv_ID)) ,'\n','\n')
cat('Connectance: ', nrow(connectance_data) / (length(unique(connectance_data$host_ID)) * length(unique(connectance_data$asv_ID))) ,'\n','\n')
cat('### Modules','\n')
cat('The color indicates number of host individuals in the module / total number of hosts in the whole grid [%]','\n','\n')
print(modules_three_villages[[i]])
cat('\n','\n')
cat('### Modules size','\n')
print(modules_size_three_villages[[i]])
cat('\n','\n')
cat('### No. of land uses','\n')
print(modules_grid_three_villages[[i]])
cat('\n','\n')
}
cat('## Observed NMI','\n')
# making a data frame out of the shuffled results
# loop for three villages
nmi_observed_df_tv <- NULL
for (j in 1:3) {
nmi_observed_df <- data_frame(nmi = nmi_observed_three_villages[[j*2]]) %>%
mutate(village = village_names[j])
nmi_observed_df_tv <- rbind(nmi_observed_df_tv, nmi_observed_df)
}
# making a data frame out of the observed results
nmi_observed_three_villages_df <- nmi_observed_three_villages[[1]] %>%
bind_rows(nmi_observed_three_villages[[3]]) %>%
bind_rows(nmi_observed_three_villages[[5]]) %>%
mutate(village = village_names)
g <- nmi_observed_df_tv %>%
ggplot(aes(nmi, fill=village)) +
geom_histogram(alpha=0.8, color="white") +
facet_wrap(~village, scales="free") +
scale_y_continuous(limits = c(0, 100)) +
geom_vline(data=nmi_observed_three_villages_df, aes(xintercept = nmi), linetype='dashed', color="black") +
geom_label(data = nmi_observed_three_villages_df, aes(label = paste("NMI =", round(nmi,2)), x = Inf, y = Inf),
vjust = 1.5,hjust = 1.1, size = 4, color = "black", fill="white") +
theme_bw() +
theme(axis.text = element_text(size = 10, color = 'black'), title = element_text(size = 14), strip.text = element_text(size=12), panel.grid = element_blank(), legend.position="none") +
scale_y_continuous(expand = expansion(mult = c(0.01, 0.01))) +
scale_fill_manual(values=group.colors) +
labs(x="Normalized Mutual Information (NMI)", y="Count")
print(g)
cat('\n','\n')
cat('## NMI for common microbes','\n')
nmi_observed_df <- nmi_diff_core_three_villages %>%
filter(type=="core", degree==1) %>%
arrange(village)
p1 <- nmi_diff_core_three_villages %>%
filter(type == "core") %>%
mutate(nmi = ifelse(is.na(nmi),0,nmi)) %>%
ggplot(aes(x=degree, y=nmi, color = village)) +
#geom_hline(yintercept=nmi_observed_df$nmi, linetype = "dashed", color=group.colors) +
geom_line() +
geom_point(aes(shape = as.factor(sig), size = n_module)) +
scale_size_continuous( breaks = c(1,10,40,80)) +
scale_shape_manual(values = c(1, 16), guide="none") +
scale_y_continuous(limits = c(0, 0.35)) +
scale_x_continuous(limits = c(0, 20)) +
theme_bw() +
theme(axis.text = element_text(size = 12, color = 'black'), title = element_text(size = 15), panel.grid = element_blank(), panel.border = element_rect(color = "black"), legend.position = c(.95, .95), legend.justification = c("right", "top"),  legend.title = element_text(size = 12)) +
scale_color_manual(values=group.colors) +
guides(size = guide_legend(order = 2), color = guide_legend(order = 1)) +
labs(x="Minimum ASVs Degree", y="Normalized Mutual Information (NMI)", size = "No. of Modules", color = "Village")
print(p1)
#legend.position = c(.95, .95), legend.justification = c("right", "top"),
cat('\n','\n')
# reading grid similarity results
grids_similarity_attr <- read_csv("../data/data_processed/village_summary.csv")
# correlations between variables
# loop for three villages
library(psych)
for (j in village_names) {
cat('###',j,'\n','\n')
print(psych::pairs.panels(grids_similarity_attr %>% filter(village == j) %>%  select(-village,-grid1,-grid2), ellipses = F, lm = T))
cat('\n','\n')
}
# mantel test for: modules similarity ~ distance between grids
# distance between grids matrices
load("../data/data_processed/distance_three_villages.RData")
mantel_result_three_villages <- NULL
final_data_three_villages <- NULL
# loop for three villages
for (i in 1:3) {
modules_similarity <- modules_similarity_three_villages[[i]]
grid_names <- rownames(modules_similarity)
grid_distance <- grid_distance_three_villages[[i]]
# filtering the distance matrix to the existing grids
grid_distance <- grid_distance[grid_names, grid_names]
# calculating mantel test
mantel_result <- vegan::mantel(modules_similarity, grid_distance)
mantel_result_df <- data_frame(r = round(mantel_result$statistic,2),
pvalue = round(1-mantel_result$signif,4),
village = village_names[i])
mantel_result_three_villages <- rbind(mantel_result_three_villages, mantel_result_df)
# transforming to long format
modules_similarity_m <- modules_similarity
modules_similarity_m[lower.tri(modules_similarity_m)] <- NA
diag(modules_similarity_m) <- NA
final_data <- melt(modules_similarity_m) %>%
filter(!is.na(value)) %>%
dplyr::rename(grid1 = Var2, grid2 = Var1, module_similarity = value) %>%
left_join(grids_similarity_attr %>% filter(village == village_names[i]), by=c("grid1","grid2"))
final_data_three_villages <- rbind(final_data_three_villages, final_data)
}
# plotting
g <- final_data_three_villages %>%
ggplot(aes(y=module_similarity, x=grid_dist, color = village)) +
geom_point(alpha = 0.8) +
facet_wrap(~village, scales="free")+
scale_y_continuous(limits = c(0.0, 0.6)) +
geom_smooth(method = "glm", se=T, method.args = list(family = "gaussian")) +
geom_text(data = mantel_result_three_villages, aes(label = paste("r =", r), x = Inf, y = Inf),
hjust = 1.3, vjust = 1.5, size = 4, color = "black") +
geom_text(data = mantel_result_three_villages, aes(label = paste("p-value =", pvalue), x = Inf, y = Inf),
hjust = 1.1, vjust = 3, size = 4, color = "black") +
theme_bw() +
theme(axis.text = element_text(size = 10, color = 'black'), title = element_text(size = 14), strip.text.x = element_text(size=12),
panel.grid = element_blank(), legend.position = "none", panel.border = element_rect(color = "black")) +
scale_color_manual(values=group.colors) +
labs(x = "Distance Between Land Uses [m]", y = "Modules Similarity [Bray-Curtis]")
print(g)
cat('\n','\n')
source("modularity_analysis_functions.R", local = knitr::knit_global())
# reading the microbiome data
# working only with Rattus from the three villages
data_asv <- read_csv("../data/data_processed/microbiome/data_asv_rra0.01_th1000_clean.csv") %>%
filter(host_species == "Rattus rattus" & grid!="village")
group.colors <- c(Andatsakala = "#e76f51", Mandena = "#2b9348", Sarahandrano = "#0077b6")
#####
# adding taxonomy
tax <- read_delim("../data/data_raw/data_microbiome/ASVs_taxonomy_new.tsv") %>%
dplyr::rename(asv_ID = ASV)
#####
# adding taxonomy
tax <- read_delim("data/data_raw/data_microbiome/ASVs_taxonomy_new.tsv") %>%
dplyr::rename(asv_ID = ASV)
View(tax)
source("modularity_analysis_functions.R", local = knitr::knit_global())
# reading the microbiome data
# working only with Rattus from the three villages
data_asv <- read_csv("../data/data_processed/microbiome/data_asv_rra0.01_th1000_clean.csv") %>%
filter(host_species == "Rattus rattus" & grid!="village")
group.colors <- c(Andatsakala = "#e76f51", Mandena = "#2b9348", Sarahandrano = "#0077b6")
# first of all, run this chunk of code.
# this code does all the modularity analysis using the functions in "modularity_analysis_functions".
# There is a loop runs for the three villages, and all the analysis is done separately for each village.
# the output of the code is variables holding the final results tables and figures (the output of the functions used)
# setting thresholds for core
core_seq <- seq(1,20, by=1)
village_names <- unique(data_asv$village)
nmi_observed_three_villages <- NULL
nmi_diff_core_three_villages <- NULL
modules_similarity_three_villages <- NULL
asv_degree_distribution_three_villages <- NULL
modules_three_villages <- NULL
modules_size_three_villages <- NULL
modules_grid_three_villages <- NULL
modules_table_three_villages <- NULL
betaNTI_three_villages <- NULL
raupc_three_villages <- NULL
# reading the phylogenetic tree
best_tree <- readRDS(file = "../results/phylo_tree_0.01_2.rds")
phylo_tree <- best_tree$tree
# ASVs phylogenetic distance
asv_distance <- ape::cophenetic.phylo(phylo_tree)
# for loop for three villages
for (v in village_names) {
data_asv_village <- data_asv %>%
filter(village == v)
# calculating ASVs degree
asv_degree <- data_asv_village %>%
group_by(asv_ID) %>%
summarise(n = n_distinct(host_ID)) %>%
rename(asv_degree = n)
data_asv_village %<>% left_join(asv_degree, by="asv_ID")
##### observed network
# finding modules
modules_observed <- fun_modularity_analysis(data_asv_village)
modules_table_three_villages <- rbind(modules_table_three_villages, modules_observed)
#write_csv(modules_table_three_villages, "../results/modules_table_three_villages.csv")
# calculating similarity in modules between grids
modules_similarity <- fun_modules_similarity(modules_observed)
# saving results in one table
modules_similarity_three_villages <- append(modules_similarity_three_villages, modules_similarity)
# ASVs degree distribution
asv_degree_distribution <- fun_asv_degree_distribution(data_asv_village)
asv_degree_distribution_three_villages <- append(asv_degree_distribution_three_villages, asv_degree_distribution)
# figure of modules
modules <- fun_modules(modules_observed)
modules_three_villages <- append(modules_three_villages, modules)
# modules size
modules_size <- fun_module_size(modules_observed)
modules_size_three_villages <- append(modules_size_three_villages, modules_size)
# Number of land uses per module
modules_grid <- fun_module_grid(modules_observed)
modules_grid_three_villages <- append(modules_grid_three_villages, modules_grid)
# calculating NMI
nmi_observed <- fun_nmi_calc(modules_observed, TRUE)
# saving results in one list
nmi_observed_three_villages <- append(nmi_observed_three_villages, nmi_observed)
##### NMI for different values of core microbiome
# calling the function
nmi_diff_core <- fun_modularity_diff_core(data_asv_village, nmi_observed, core_seq) %>%
mutate(village = v)
# saving results in one list
nmi_diff_core_three_villages <- rbind(nmi_diff_core_three_villages, nmi_diff_core)
##### phylogenetic analysis
# ASVs pool
asv_pool <- data_asv_village %>%
distinct(asv_ID, asv_degree) %>%
mutate(p = asv_degree/length(unique(data_asv_village$asv_ID)))
# calculating betaNTI
data_betaNTI <- data_asv_village %>%
distinct(host_ID, asv_ID) %>%
mutate(reads = 1) %>%
spread(asv_ID, reads, fill = 0) %>%
column_to_rownames("host_ID") %>%
as.matrix()
betaNTI <- fun_calc_betaNTI(data_betaNTI, asv_distance, asv_pool) %>%
left_join(modules_observed %>% distinct(host_ID, host_group, grid), by=c("host1"="host_ID")) %>% rename(host_group1=host_group, grid1=grid) %>%
left_join(modules_observed %>% distinct(host_ID, host_group, grid), by=c("host2"="host_ID")) %>% rename(host_group2=host_group, grid2=grid) %>%
mutate(village = v)
betaNTI_three_villages <- rbind(betaNTI_three_villages, betaNTI)
# raup-crick
raupc <- raupcrick(data_betaNTI)
raupc2 <- as.matrix(raupc)
raupc2[upper.tri(raupc2)] <- NA
diag(raupc2) <- NA
raupc2_m <- melt(raupc2) %>%
filter(!(is.na(value)))%>%
rename(host1 = Var1, host2 = Var2, raupc = value) %>%
left_join(modules_observed %>% distinct(host_ID, host_group, grid), by=c("host1"="host_ID")) %>% rename(host_group1=host_group, grid1=grid) %>%
left_join(modules_observed %>% distinct(host_ID, host_group, grid), by=c("host2"="host_ID")) %>% rename(host_group2=host_group, grid2=grid) %>%
mutate(village = v)
raupc_three_villages <- rbind(raupc_three_villages, raupc2_m)
}
# mantel test for: modules similarity ~ distance between grids
# distance between grids matrices
load("../data/data_processed/distance_three_villages.RData")
mantel_result_three_villages <- NULL
final_data_three_villages <- NULL
# loop for three villages
for (i in 1:3) {
modules_similarity <- modules_similarity_three_villages[[i]]
grid_names <- rownames(modules_similarity)
grid_distance <- grid_distance_three_villages[[i]]
# filtering the distance matrix to the existing grids
grid_distance <- grid_distance[grid_names, grid_names]
# calculating mantel test
mantel_result <- vegan::mantel(modules_similarity, grid_distance)
mantel_result_df <- data_frame(r = round(mantel_result$statistic,2),
pvalue = round(1-mantel_result$signif,4),
village = village_names[i])
mantel_result_three_villages <- rbind(mantel_result_three_villages, mantel_result_df)
# transforming to long format
modules_similarity_m <- modules_similarity
modules_similarity_m[lower.tri(modules_similarity_m)] <- NA
diag(modules_similarity_m) <- NA
final_data <- melt(modules_similarity_m) %>%
filter(!is.na(value)) %>%
dplyr::rename(grid1 = Var2, grid2 = Var1, module_similarity = value) %>%
left_join(grids_similarity_attr %>% filter(village == village_names[i]), by=c("grid1","grid2"))
final_data_three_villages <- rbind(final_data_three_villages, final_data)
}
# reading grid similarity results
grids_similarity_attr <- read_csv("../data/data_processed/village_summary.csv")
# correlations between variables
# loop for three villages
library(psych)
for (j in village_names) {
cat('###',j,'\n','\n')
print(psych::pairs.panels(grids_similarity_attr %>% filter(village == j) %>%  select(-village,-grid1,-grid2), ellipses = F, lm = T))
cat('\n','\n')
}
# mantel test for: modules similarity ~ distance between grids
# distance between grids matrices
load("../data/data_processed/distance_three_villages.RData")
mantel_result_three_villages <- NULL
final_data_three_villages <- NULL
# loop for three villages
for (i in 1:3) {
modules_similarity <- modules_similarity_three_villages[[i]]
grid_names <- rownames(modules_similarity)
grid_distance <- grid_distance_three_villages[[i]]
# filtering the distance matrix to the existing grids
grid_distance <- grid_distance[grid_names, grid_names]
# calculating mantel test
mantel_result <- vegan::mantel(modules_similarity, grid_distance)
mantel_result_df <- data_frame(r = round(mantel_result$statistic,2),
pvalue = round(1-mantel_result$signif,4),
village = village_names[i])
mantel_result_three_villages <- rbind(mantel_result_three_villages, mantel_result_df)
# transforming to long format
modules_similarity_m <- modules_similarity
modules_similarity_m[lower.tri(modules_similarity_m)] <- NA
diag(modules_similarity_m) <- NA
final_data <- melt(modules_similarity_m) %>%
filter(!is.na(value)) %>%
dplyr::rename(grid1 = Var2, grid2 = Var1, module_similarity = value) %>%
left_join(grids_similarity_attr %>% filter(village == village_names[i]), by=c("grid1","grid2"))
final_data_three_villages <- rbind(final_data_three_villages, final_data)
}
# plotting
g <- final_data_three_villages %>%
ggplot(aes(y=module_similarity, x=grid_dist, color = village)) +
geom_point(alpha = 0.8) +
facet_wrap(~village, scales="free")+
scale_y_continuous(limits = c(0.0, 0.6)) +
geom_smooth(method = "glm", se=T, method.args = list(family = "gaussian")) +
geom_text(data = mantel_result_three_villages, aes(label = paste("r =", r), x = Inf, y = Inf),
hjust = 1.3, vjust = 1.5, size = 4, color = "black") +
geom_text(data = mantel_result_three_villages, aes(label = paste("p-value =", pvalue), x = Inf, y = Inf),
hjust = 1.1, vjust = 3, size = 4, color = "black") +
theme_bw() +
theme(axis.text = element_text(size = 10, color = 'black'), title = element_text(size = 14), strip.text.x = element_text(size=12),
panel.grid = element_blank(), legend.position = "none", panel.border = element_rect(color = "black")) +
scale_color_manual(values=group.colors) +
labs(x = "Distance Between Land Uses [m]", y = "Modules Similarity [Bray-Curtis]")
print(g)
cat('\n','\n')
# plotting
g <- final_data_three_villages %>%
ggplot(aes(y=module_similarity, x=grid_attr, color = village)) +
geom_point(alpha = 0.8) +
facet_wrap(~village, scales="free")+
scale_y_continuous(limits = c(0.0, 0.6)) +
geom_smooth(method = "glm", se=T, method.args = list(family = "gaussian")) +
geom_text(data = mantel_result_three_villages, aes(label = paste("r =", r), x = Inf, y = Inf),
hjust = 1.3, vjust = 1.5, size = 4, color = "black") +
geom_text(data = mantel_result_three_villages, aes(label = paste("p-value =", pvalue), x = Inf, y = Inf),
hjust = 1.1, vjust = 3, size = 4, color = "black") +
theme_bw() +
theme(axis.text = element_text(size = 10, color = 'black'), title = element_text(size = 14), strip.text.x = element_text(size=12),
panel.grid = element_blank(), legend.position = "none", panel.border = element_rect(color = "black")) +
scale_color_manual(values=group.colors) +
labs(x = "Distance Between Land Uses [m]", y = "Modules Similarity [Bray-Curtis]")
print(g)
# plotting
g <- final_data_three_villages %>%
ggplot(aes(y=module_similarity, x=grid_dist, color = village)) +
geom_point(alpha = 0.8) +
facet_wrap(~village, scales="free")+
scale_y_continuous(limits = c(0.0, 0.6)) +
geom_smooth(method = "glm", se=T, method.args = list(family = "gaussian")) +
geom_text(data = mantel_result_three_villages, aes(label = paste("r =", r), x = Inf, y = Inf),
hjust = 1.3, vjust = 1.5, size = 4, color = "black") +
geom_text(data = mantel_result_three_villages, aes(label = paste("p-value =", pvalue), x = Inf, y = Inf),
hjust = 1.1, vjust = 3, size = 4, color = "black") +
theme_bw() +
theme(axis.text = element_text(size = 10, color = 'black'), title = element_text(size = 14), strip.text.x = element_text(size=12),
panel.grid = element_blank(), legend.position = "none", panel.border = element_rect(color = "black")) +
scale_color_manual(values=group.colors) +
labs(x = "Distance Between Land Uses [m]", y = "Modules Similarity [Bray-Curtis]")
print(g)
# reading ASVs raw data
data_asv <- read_csv("data/data_raw/data_microbiome/merged_full_sample_table.csv")
data_asv %<>% filter(sample_type == "SAMPLE") %>%
filter(!(grepl("D",Sample_Name)))
data_asv %<>% mutate(host_ID = as.numeric(gsub(".*?([0-9]+).*", "\\1", Sample_Name)))
View(data_asv)
# reading ASVs raw data
data_asv <- read_csv("data/data_raw/data_microbiome/merged_full_sample_table.csv")
rm(list=ls())
# reading ASVs raw data
data_asv <- read_csv("data/data_raw/data_microbiome/merged_full_sample_table.csv")
View(data_asv)
a=data_asv %>% filter(sample_type=="NEG")
a=data_asv %>% filter(sample_type=="CONT")
View(a)
a=data_asv %>% filter(sample_type=="POS")
data_asv %<>% filter(sample_type == "SAMPLE") %>%
filter(!(grepl("D",Sample_Name)))
data_asv %<>% mutate(host_ID = as.numeric(gsub(".*?([0-9]+).*", "\\1", Sample_Name)))
# combining asv data and SM data
data_asv_f <- data_asv %>%
dplyr::select(host_ID, unfiltered_reads, contains("ASV"))
# reading small mammals data
data_mammals <- read_csv("data/data_raw/data_small_mammals/Terrestrial_Mammals.csv")
# extracting samples IDs (taking only numbers due to unmatching formats)
data_mammals %<>% mutate(host_ID = as.numeric(gsub(".*?([0-9]+).*", "\\1", animal_id)))
# matching small-mammals (SM) IDs in the two data files and taking only SM with microbes data
data_sm <- semi_join(data_mammals, data_asv, by="host_ID") %>%
dplyr::select(host_ID, field_identification, village, habitat_type, season) %>%
dplyr::rename(host_species = field_identification, grid = habitat_type) %>%
mutate(season = factor(season, levels = c("1","2","3"))) %>%
mutate(grid = factor(grid, levels = c("semi-intact_forest","secondary_forest","brushy_regrowth","agriculture","flooded_rice","agroforest","village")))
dat <- left_join(data_sm, data_asv_f, by="host_ID")
View(dat)
# filtering non-rattus host species
dat2 <- dat %>%
filter(host_species == "Rattus rattus")
View(dat2)
data_asv <- read_csv("../data/data_processed/microbiome/data_asv_rra0.01_th1000_clean.csv") %>%
filter(host_species == "Rattus rattus")
length(unique(data_asv$host_ID))
asv_total_reads <- colSums(dat1 %>% select(starts_with("ASV")))
##### filter 1
# filtering non-rattus host species
dat1 <- dat %>%
filter(host_species == "Rattus rattus")
asv_total_reads <- colSums(dat1 %>% select(starts_with("ASV")))
asv_total_reads[1:10]
asv_total_reads_low <- which(asv_total_reads[asv_total_reads<asv_total_reads_th])
##### filter 2
# removing ASVs with very low total reads across the whole dataset
asv_total_reads_th <- 100
asv_total_reads_low <- which(asv_total_reads[asv_total_reads<asv_total_reads_th])
?which
asv_total_reads_low <- asv_total_reads[asv_total_reads<asv_total_reads_th]
View(dat1)
##### filter 1
# filtering non-rattus host species
dat1 <- dat %>%
filter(host_species == "Rattus rattus") %>%
select_if(~ any(. != 0))
View(dat1)
22715-10358
asv_total_reads <- colSums(dat1 %>% select(starts_with("ASV")))
asv_total_reads_low <- asv_total_reads[asv_total_reads<asv_total_reads_th]
asv_total_reads_low[1:10]
##### filter 2
# removing ASVs with very low total reads across the whole dataset
asv_total_reads_th <- 10
asv_total_reads <- colSums(dat1 %>% select(starts_with("ASV")))
asv_total_reads_low <- asv_total_reads[asv_total_reads<asv_total_reads_th]
dat2 <- dat1 %>%
select(!names(asv_total_reads_low))
View(dat2)
# counting ASVs occurences
asv_occur <- dat2 %>%
summarise(across(everything(), ~ sum(. != 0)))
View(asv_occur)
# counting ASVs occurences
asv_occur <- dat2 %>%
summarise(across(everything(), ~ sum(. != 0))) %>%
as.vector()
# counting ASVs occurences
asv_occur <- dat2 %>%
summarise(across(everything(), ~ sum(. != 0))) %>%
as.matrix()
View(asv_occur)
# counting ASVs occurrences
asv_occur_th <- 2
asv_occur_high <- asv_occur[asv_occur > asv_occur_th]
##### filter 2
# removing ASVs with very low total reads across the whole dataset
asv_total_reads_th <- 100
asv_total_reads <- colSums(dat1 %>% select(starts_with("ASV")))
asv_total_reads_low <- asv_total_reads[asv_total_reads<asv_total_reads_th]
dat2 <- dat1 %>%
select(!names(asv_total_reads_low))
# counting ASVs occurrences
asv_occur_th <- 2
asv_occur <- dat2 %>%
summarise(across(everything(), ~ sum(. != 0))) %>%
as.matrix()
asv_occur_high <- asv_occur[asv_occur > asv_occur_th]
View(asv_occur)
asv_occur <- asv_occur[-(1:6)]
hist(asv_occur)
?hist
hist(asv_occur, 100)
hist(asv_occur, 800)
asv_occur_high <- asv_occur[asv_occur > asv_occur_th]
asv_occur_low <- asv_occur[asv_occur <= asv_occur_th]
dat3 <- dat2 %>%
select(!names(asv_occur_low))
asv_occur_low[1:10]
asv_occur[1:10]
=======
# Weighted UniFrac
dist_uwunif <- 1-unifracs[, , "d_UW"]
dist_uwunif[lower.tri(dist_uwunif)] <- NA
diag(dist_uwunif) <- NA
dist_uwunif_m <- melt(dist_uwunif) %>%
rename(uwunifrac = value) %>%
filter(!(is.na(uwunifrac))) %>%
left_join(dat_beta %>% dplyr::select(host_ID,grid),by=c("Var1"="host_ID")) %>%
left_join(dat_beta %>% dplyr::select(host_ID,grid),by=c("Var2"="host_ID")) %>%
filter(grid.x==grid.y)
# combining indeces
dists <- bind_cols(dist_jaccard_m, bray=dist_bray_m$bray) %>%
bind_cols(w_unifrac=dist_wunif_m$wunifrac) %>%
bind_cols(uw_unifrac=dist_uwunif_m$uwunifrac) %>%
gather("index","value",jaccard, bray, w_unifrac, un_unifrac)
# calculating the mean
dist_mean <- dists %>%
group_by(grid.x, index) %>%
summarise(mean = mean(value))
# Plotting
g <- dists %>%
ggplot(aes(value, fill=index, cut=index)) +
geom_density(alpha=.4) +
facet_wrap(~grid.x) +
theme_bw() +
theme(axis.text = element_text(size = 10, color = 'black'), title = element_text(size = 14), strip.text.x = element_text(size = 12)) +
xlim(0, 1) +
geom_vline(data=dist_mean, aes(xintercept=mean, color=index), linetype="dashed")+
guides(fill=guide_legend(title="Similarity Index")) +
labs(x="Community similarity",y="Density")
print(g)
cat('\n','\n')
}
for(s in common_sp) {
cat('###',s,'\n','\n')
# preparing the data
dat_beta <- dat %>% filter(host_species == s)
dat_asv_beta <- dat_beta %>%
column_to_rownames("host_ID") %>%
dplyr::select(starts_with("ASV")) %>%
dplyr::select(where(~ any(. > 0, na.rm = TRUE)))
# Jaccard
dat_asv_j <- dat_asv_beta %>% mutate_all(funs(ifelse(.>0,1,0)))
dist_jaccard <- as.matrix(1-vegdist(dat_asv_j, "jaccard"))
dist_jaccard[lower.tri(dist_jaccard)] <- NA
diag(dist_jaccard) <- NA
dist_jaccard_m <- melt(dist_jaccard) %>%
rename(jaccard = value) %>%
filter(!(is.na(jaccard))) %>%
left_join(dat_beta %>% dplyr::select(host_ID,grid),by=c("Var1"="host_ID")) %>%
left_join(dat_beta %>% dplyr::select(host_ID,grid),by=c("Var2"="host_ID")) %>%
filter(grid.x==grid.y)
# Bray-Curtis
dist_bray <- as.matrix(1-vegdist(dat_asv_beta, "bray"))
dist_bray[lower.tri(dist_bray)] <- NA
diag(dist_bray) <- NA
dist_bray_m <- melt(dist_bray) %>%
rename(bray = value) %>%
filter(!(is.na(bray))) %>%
left_join(dat_beta %>% dplyr::select(host_ID,grid),by=c("Var1"="host_ID")) %>%
left_join(dat_beta %>% dplyr::select(host_ID,grid),by=c("Var2"="host_ID")) %>%
filter(grid.x==grid.y)
#  UniFrac
# pruning the tree
included_asvs <- colnames(dat_asv_beta)
unincluded <- rooted_tree$tip.label[!rooted_tree$tip.label %in% included_asvs]
pruned <- dendextend::prune(rooted_tree, unincluded)
unifracs <- GUniFrac(as.matrix(dat_asv_beta), pruned, alpha=c(0, 0.5, 1))$unifracs
# Weighted UniFrac
dist_wunif <- 1-unifracs[, , "d_1"]
dist_wunif[lower.tri(dist_wunif)] <- NA
diag(dist_wunif) <- NA
dist_wunif_m <- melt(dist_wunif) %>%
rename(wunifrac = value) %>%
filter(!(is.na(wunifrac))) %>%
left_join(dat_beta %>% dplyr::select(host_ID,grid),by=c("Var1"="host_ID")) %>%
left_join(dat_beta %>% dplyr::select(host_ID,grid),by=c("Var2"="host_ID")) %>%
filter(grid.x==grid.y)
# UnWeighted UniFrac
dist_uwunif <- 1-unifracs[, , "d_UW"]
dist_uwunif[lower.tri(dist_uwunif)] <- NA
diag(dist_uwunif) <- NA
dist_uwunif_m <- melt(dist_uwunif) %>%
rename(uwunifrac = value) %>%
filter(!(is.na(uwunifrac))) %>%
left_join(dat_beta %>% dplyr::select(host_ID,grid),by=c("Var1"="host_ID")) %>%
left_join(dat_beta %>% dplyr::select(host_ID,grid),by=c("Var2"="host_ID")) %>%
filter(grid.x==grid.y)
# combining indeces
dists <- bind_cols(dist_jaccard_m, bray=dist_bray_m$bray) %>%
bind_cols(w_unifrac=dist_wunif_m$wunifrac) %>%
bind_cols(uw_unifrac=dist_uwunif_m$uwunifrac) %>%
gather("index","value",jaccard, bray, w_unifrac, uw_unifrac)
# calculating the mean
dist_mean <- dists %>%
group_by(grid.x, index) %>%
summarise(mean = mean(value))
# Plotting
g <- dists %>%
ggplot(aes(value, fill=index, cut=index)) +
geom_density(alpha=.4) +
facet_wrap(~grid.x) +
theme_bw() +
theme(axis.text = element_text(size = 10, color = 'black'), title = element_text(size = 14), strip.text.x = element_text(size = 12)) +
xlim(0, 1) +
geom_vline(data=dist_mean, aes(xintercept=mean, color=index), linetype="dashed")+
guides(fill=guide_legend(title="Similarity Index")) +
labs(x="Community similarity",y="Density")
print(g)
cat('\n','\n')
}
?metaMDS
# pruning the tree
included_asvs <- colnames(dat_asv_beta)
unincluded <- rooted_tree$tip.label[!rooted_tree$tip.label %in% included_asvs]
pruned <- dendextend::prune(rooted_tree, unincluded)
unifracs <- GUniFrac(as.matrix(dat_asv_beta), pruned, alpha=c(0, 0.5, 1))$unifracs
dist_wunif <- 1-unifracs[, , "d_1"]
nmds_wunif <- metaMDS(dist_wunif, k=2, trace = FALSE) #NMDS
# stressplot(nmds_bray)
NMDS1<-nmds_bray$points[,1]
NMDS2<-nmds_bray$points[,2]
# stressplot(nmds_bray)
NMDS1<-nmds_wunif$points[,1]
NMDS2<-nmds_wunif$points[,2]
bray_plot <- cbind(dat_beta, NMDS1, NMDS2)
# plotting
g <- bray_plot %>%
ggplot( aes(NMDS1, NMDS2, color=grid)) +
geom_point(position=position_jitter(.1)) +
stat_ellipse(aes(fill=grid), alpha=.1, type='norm',linetype =2, geom="polygon") + ##draws 95% confidence interval ellipses
theme_minimal() +
annotate("text", x=0, y=max(abs(NMDS2)), label=paste('Stress =',round(nmds_bray$stress,3))) # adding stress
# plotting
g <- bray_plot %>%
ggplot( aes(NMDS1, NMDS2, color=grid)) +
geom_point(position=position_jitter(.1)) +
stat_ellipse(aes(fill=grid), alpha=.1, type='norm',linetype =2, geom="polygon") + ##draws 95% confidence interval ellipses
theme_minimal() +
annotate("text", x=0, y=max(abs(NMDS2)), label=paste('Stress =',round(nmds_wunif$stress,3))) # adding stress
print(g)
stressplot(nmds_wunif)
set.seed(199)
for(s in common_sp) {
cat('###',s,'\n','\n')
# preparing the data
dat_beta <- dat %>% filter(host_species == s)
dat_asv_beta <- dat_beta %>%
column_to_rownames("host_ID") %>%
dplyr::select(starts_with("ASV")) %>%
dplyr::select(where(~ any(. > 0, na.rm = TRUE)))
# Jaccard
cat("Jaccard \n")
dat_asv_beta_j <- dat_asv_beta %>%  mutate_all(funs(ifelse(.>0,1,0)))
dist_jaccard <- vegdist(dat_asv_beta_j, method = "jaccard") # distance matrix
beta_jaccard <- adonis2(formula = dist_jaccard ~ grid, data = dat_beta) # PERMANOVA
results_a <- beta_jaccard[1,5]
disp_jaccard <- betadisper(dist_jaccard, group=dat_beta$grid) # PERMDISP - dispersion
results_b <- anova(disp_jaccard)[1,5]
results_sum <- tibble(PERMANOVA = results_a, PERMDIST = results_b)
print(knitr::kable(results_sum))
cat('\n')
# PERMANOVA post-hoc
beta_post_jaccard <- RVAideMemoire::pairwise.perm.manova(dist_jaccard, fact = dat_beta$grid,
test = "bonferroni", nperm = 999, progress = FALSE)$p.value %>% as.data.frame()
print(knitr::kable(beta_post_jaccard))
cat('\n')
# Tukey test to check pairwise dispersion comparisons
disp_tuk_jaccard <- TukeyHSD(disp_jaccard)$group %>% as.data.frame() %>% dplyr::select("p adj")
print(knitr::kable(disp_tuk_jaccard))
cat('\n')
# checking for outliers (disconnected samples)
dis <- distconnected(dist_jaccard)
if(length(unique(dis)) > 1){
dat_asv_beta <- dat_asv_beta[dis==1,]  # removing them
dat_asv_beta_j <- dat_asv_beta_j[dis==1,]
dat_beta <- dat_beta[dis==1,]
}
nmds_jaccard <- metaMDS(dat_asv_beta_j, distance = "jaccard", noshare = TRUE, k=2, trace = FALSE) #NMDS
# stressplot(nmds_jaccard)
NMDS1<-nmds_jaccard$points[,1]
NMDS2<-nmds_jaccard$points[,2]
jaccard_plot <- cbind(dat_beta, NMDS1, NMDS2)
# plotting
g <- jaccard_plot %>%
ggplot( aes(NMDS1, NMDS2, color=grid)) +
geom_point(position=position_jitter(.1)) +
stat_ellipse(aes(fill=grid), alpha=.1, type='norm',linetype =2, geom="polygon") + ##draws 95% confidence interval ellipses
theme_minimal() +
annotate("text", x=0, y=max(abs(NMDS2)), label=paste('Stress =',round(nmds_jaccard$stress,3))) # adding stress
print(g)
cat('\n')
# Bray-curtis
cat("Bray-Curtis \n")
dist_bray <- vegdist(dat_asv_beta, method = "bray") # distance matrix
beta_bray <- adonis2(formula = dist_bray ~ grid, data = dat_beta) # PERMANOVA
results_a <- beta_bray[1,5]
disp_bray <- betadisper(dist_bray, group=dat_beta$grid) # PERMDISP - dispersion
results_b <- anova(disp_bray)[1,5]
results_sum <- tibble(PERMANOVA = results_a, PERMDIST = results_b)
print(knitr::kable(results_sum))
cat('\n')
# PERMANOVA post-hoc
beta_post_bray <- RVAideMemoire::pairwise.perm.manova(dist_bray, fact = dat_beta$grid,
test = "bonferroni", nperm = 999, progress = FALSE)$p.value %>% as.data.frame()
print(knitr::kable(beta_post_bray))
cat('\n')
# Tukey test to check pairwise dispersion comparisons
disp_tuk_bray <- TukeyHSD(disp_bray)$group %>% as.data.frame() %>% dplyr::select("p adj")
print(knitr::kable(disp_tuk_bray))
cat('\n')
nmds_bray <- metaMDS(dat_asv_beta, distance = "bray", k=2, noshare = TRUE, trace = FALSE) #NMDS
# stressplot(nmds_bray)
NMDS1<-nmds_bray$points[,1]
NMDS2<-nmds_bray$points[,2]
bray_plot <- cbind(dat_beta, NMDS1, NMDS2)
# plotting
g <- bray_plot %>%
ggplot( aes(NMDS1, NMDS2, color=grid)) +
geom_point(position=position_jitter(.1)) +
stat_ellipse(aes(fill=grid), alpha=.1, type='norm',linetype =2, geom="polygon") + ##draws 95% confidence interval ellipses
theme_minimal() +
annotate("text", x=0, y=max(abs(NMDS2)), label=paste('Stress =',round(nmds_bray$stress,3))) # adding stress
print(g)
cat('\n')
# Weighted UniFrac
cat("Weighted UniFrac \n")
# pruning the tree
included_asvs <- colnames(dat_asv_beta)
unincluded <- rooted_tree$tip.label[!rooted_tree$tip.label %in% included_asvs]
pruned <- dendextend::prune(rooted_tree, unincluded)
unifracs <- GUniFrac(as.matrix(dat_asv_beta), pruned, alpha=c(0, 0.5, 1))$unifracs
dist_wunif <- 1-unifracs[, , "d_1"]
beta_wunif <- adonis2(formula = dist_wunif ~ grid, data = dat_beta) # PERMANOVA
results_a <- beta_wunif[1,5]
disp_wunif <- betadisper(dist_wunif, group=dat_beta$grid) # PERMDISP - dispersion
results_b <- anova(disp_wunif)[1,5]
results_sum <- tibble(PERMANOVA = results_a, PERMDIST = results_b)
print(knitr::kable(results_sum))
cat('\n')
# PERMANOVA post-hoc
beta_post_wunif <- RVAideMemoire::pairwise.perm.manova(dist_wunif, fact = dat_beta$grid,
test = "bonferroni", nperm = 999, progress = FALSE)$p.value %>% as.data.frame()
print(knitr::kable(beta_post_bray))
cat('\n')
# Tukey test to check pairwise dispersion comparisons
disp_tuk_wunif <- TukeyHSD(disp_wunif)$group %>% as.data.frame() %>% dplyr::select("p adj")
print(knitr::kable(disp_tuk_bray))
cat('\n')
nmds_wunif <- metaMDS(dist_wunif, k=2, trace = FALSE) #NMDS
# stressplot(nmds_wunif)
NMDS1<-nmds_wunif$points[,1]
NMDS2<-nmds_wunif$points[,2]
bray_plot <- cbind(dat_beta, NMDS1, NMDS2)
# plotting
g <- bray_plot %>%
ggplot( aes(NMDS1, NMDS2, color=grid)) +
geom_point(position=position_jitter(.1)) +
stat_ellipse(aes(fill=grid), alpha=.1, type='norm',linetype =2, geom="polygon") + ##draws 95% confidence interval ellipses
theme_minimal() +
annotate("text", x=0, y=max(abs(NMDS2)), label=paste('Stress =',round(nmds_wunif$stress,3))) # adding stress
print(g)
cat('\n','\n')
}
?as.dist
dist_wunif <- as.dist(1-unifracs[, , "d_1"])
dist_wunif <- 1-unifracs[, , "d_1"]
dist_wunif <- as.dist(1-unifracs[, , "d_1"])
set.seed(199)
for(s in common_sp) {
cat('###',s,'\n','\n')
# preparing the data
dat_beta <- dat %>% filter(host_species == s)
dat_asv_beta <- dat_beta %>%
column_to_rownames("host_ID") %>%
dplyr::select(starts_with("ASV")) %>%
dplyr::select(where(~ any(. > 0, na.rm = TRUE)))
# Jaccard
cat("Jaccard \n")
dat_asv_beta_j <- dat_asv_beta %>%  mutate_all(funs(ifelse(.>0,1,0)))
dist_jaccard <- vegdist(dat_asv_beta_j, method = "jaccard") # distance matrix
beta_jaccard <- adonis2(formula = dist_jaccard ~ grid, data = dat_beta) # PERMANOVA
results_a <- beta_jaccard[1,5]
disp_jaccard <- betadisper(dist_jaccard, group=dat_beta$grid) # PERMDISP - dispersion
results_b <- anova(disp_jaccard)[1,5]
results_sum <- tibble(PERMANOVA = results_a, PERMDIST = results_b)
print(knitr::kable(results_sum))
cat('\n')
# PERMANOVA post-hoc
beta_post_jaccard <- RVAideMemoire::pairwise.perm.manova(dist_jaccard, fact = dat_beta$grid,
test = "bonferroni", nperm = 999, progress = FALSE)$p.value %>% as.data.frame()
print(knitr::kable(beta_post_jaccard))
cat('\n')
# Tukey test to check pairwise dispersion comparisons
disp_tuk_jaccard <- TukeyHSD(disp_jaccard)$group %>% as.data.frame() %>% dplyr::select("p adj")
print(knitr::kable(disp_tuk_jaccard))
cat('\n')
# checking for outliers (disconnected samples)
dis <- distconnected(dist_jaccard)
if(length(unique(dis)) > 1){
dat_asv_beta <- dat_asv_beta[dis==1,]  # removing them
dat_asv_beta_j <- dat_asv_beta_j[dis==1,]
dat_beta <- dat_beta[dis==1,]
}
nmds_jaccard <- metaMDS(dat_asv_beta_j, distance = "jaccard", noshare = TRUE, k=2, trace = FALSE) #NMDS
# stressplot(nmds_jaccard)
NMDS1<-nmds_jaccard$points[,1]
NMDS2<-nmds_jaccard$points[,2]
jaccard_plot <- cbind(dat_beta, NMDS1, NMDS2)
# plotting
g <- jaccard_plot %>%
ggplot( aes(NMDS1, NMDS2, color=grid)) +
geom_point(position=position_jitter(.1)) +
stat_ellipse(aes(fill=grid), alpha=.1, type='norm',linetype =2, geom="polygon") + ##draws 95% confidence interval ellipses
theme_minimal() +
annotate("text", x=0, y=max(abs(NMDS2)), label=paste('Stress =',round(nmds_jaccard$stress,3))) # adding stress
print(g)
cat('\n')
# Bray-curtis
cat("Bray-Curtis \n")
dist_bray <- vegdist(dat_asv_beta, method = "bray") # distance matrix
beta_bray <- adonis2(formula = dist_bray ~ grid, data = dat_beta) # PERMANOVA
results_a <- beta_bray[1,5]
disp_bray <- betadisper(dist_bray, group=dat_beta$grid) # PERMDISP - dispersion
results_b <- anova(disp_bray)[1,5]
results_sum <- tibble(PERMANOVA = results_a, PERMDIST = results_b)
print(knitr::kable(results_sum))
cat('\n')
# PERMANOVA post-hoc
beta_post_bray <- RVAideMemoire::pairwise.perm.manova(dist_bray, fact = dat_beta$grid,
test = "bonferroni", nperm = 999, progress = FALSE)$p.value %>% as.data.frame()
print(knitr::kable(beta_post_bray))
cat('\n')
# Tukey test to check pairwise dispersion comparisons
disp_tuk_bray <- TukeyHSD(disp_bray)$group %>% as.data.frame() %>% dplyr::select("p adj")
print(knitr::kable(disp_tuk_bray))
cat('\n')
nmds_bray <- metaMDS(dat_asv_beta, distance = "bray", k=2, noshare = TRUE, trace = FALSE) #NMDS
# stressplot(nmds_bray)
NMDS1<-nmds_bray$points[,1]
NMDS2<-nmds_bray$points[,2]
bray_plot <- cbind(dat_beta, NMDS1, NMDS2)
# plotting
g <- bray_plot %>%
ggplot( aes(NMDS1, NMDS2, color=grid)) +
geom_point(position=position_jitter(.1)) +
stat_ellipse(aes(fill=grid), alpha=.1, type='norm',linetype =2, geom="polygon") + ##draws 95% confidence interval ellipses
theme_minimal() +
annotate("text", x=0, y=max(abs(NMDS2)), label=paste('Stress =',round(nmds_bray$stress,3))) # adding stress
print(g)
cat('\n')
# Weighted UniFrac
cat("Weighted UniFrac \n")
# pruning the tree
included_asvs <- colnames(dat_asv_beta)
unincluded <- rooted_tree$tip.label[!rooted_tree$tip.label %in% included_asvs]
pruned <- dendextend::prune(rooted_tree, unincluded)
unifracs <- GUniFrac(as.matrix(dat_asv_beta), pruned, alpha=c(0, 0.5, 1))$unifracs
dist_wunif <- as.dist(1-unifracs[, , "d_1"])
beta_wunif <- adonis2(formula = dist_wunif ~ grid, data = dat_beta) # PERMANOVA
results_a <- beta_wunif[1,5]
disp_wunif <- betadisper(dist_wunif, group=dat_beta$grid) # PERMDISP - dispersion
results_b <- anova(disp_wunif)[1,5]
results_sum <- tibble(PERMANOVA = results_a, PERMDIST = results_b)
print(knitr::kable(results_sum))
cat('\n')
# PERMANOVA post-hoc
beta_post_wunif <- RVAideMemoire::pairwise.perm.manova(dist_wunif, fact = dat_beta$grid,
test = "bonferroni", nperm = 999, progress = FALSE)$p.value %>% as.data.frame()
print(knitr::kable(beta_post_bray))
cat('\n')
# Tukey test to check pairwise dispersion comparisons
disp_tuk_wunif <- TukeyHSD(disp_wunif)$group %>% as.data.frame() %>% dplyr::select("p adj")
print(knitr::kable(disp_tuk_bray))
cat('\n')
nmds_wunif <- metaMDS(dist_wunif, k=2, trace = FALSE) #NMDS
# stressplot(nmds_wunif)
NMDS1<-nmds_wunif$points[,1]
NMDS2<-nmds_wunif$points[,2]
bray_plot <- cbind(dat_beta, NMDS1, NMDS2)
# plotting
g <- bray_plot %>%
ggplot( aes(NMDS1, NMDS2, color=grid)) +
geom_point(position=position_jitter(.1)) +
stat_ellipse(aes(fill=grid), alpha=.1, type='norm',linetype =2, geom="polygon") + ##draws 95% confidence interval ellipses
theme_minimal() +
annotate("text", x=0, y=max(abs(NMDS2)), label=paste('Stress =',round(nmds_wunif$stress,3))) # adding stress
print(g)
cat('\n','\n')
}
install.packages("picante")
library(picante) # phylogentic diversity
dat_phylo_matrix <- dat %>%
column_to_rownames("host_ID") %>%
dplyr::select(starts_with("ASV")) %>%
dplyr::select(where(~ any(. > 0, na.rm = TRUE)))
dat_phylo <- picante::pse(dat_phylo_matrix, rooted_tree)
View(dat_phylo)
View(dat)
dat_phylo %<>% rownames_to_column() %>%
left_join(dat %>% dplyr::select(host_ID,host_species,village,grid), by="host_species")
dat_phylo %<>% rownames_to_column()
dat_phylo %<>% rownames_to_column("host_ID")
# PSE - take into account phylogenetic distance and species abundance
# min value: 0; max value: 1
dat_phylo <- picante::pse(dat_phylo_matrix, rooted_tree)
dat_phylo %<>% rownames_to_column("host_ID") %>%
left_join(dat %>% dplyr::select(host_ID,host_species,village,grid), by="host_ID")
dat_phylo %<>% rownames_to_column("host_ID")
class(dat_phylo$host_ID)
# PSE - take into account phylogenetic distance and species abundance
# min value: 0; max value: 1
dat_phylo <- picante::pse(dat_phylo_matrix, rooted_tree)
dat_phylo %<>% rownames_to_column("host_ID") %>%
as.numeric(host_ID) %>%
left_join(dat %>% dplyr::select(host_ID,host_species,village,grid), by="host_ID")
dat_phylo %<>% rownames_to_column("host_ID") %>%
as.numeric(host_ID)
class(dat$host_ID)
dat_phylo %<>% rownames_to_column("host_ID") %>%
as.numeric(host_ID)
dat_phylo %<>% rownames_to_column("host_ID")
# PSE - take into account phylogenetic distance and species abundance
# min value: 0; max value: 1
dat_phylo <- picante::pse(dat_phylo_matrix, rooted_tree)
dat_phylo %<>% rownames_to_column("host_ID") %>%
as.numeric(host_ID)
# PSE - take into account phylogenetic distance and species abundance
# min value: 0; max value: 1
dat_phylo <- picante::pse(dat_phylo_matrix, rooted_tree) %>% rownames_to_column("host_ID")
dat_phylo %<>% as.numeric(host_ID) %>%
left_join(dat %>% dplyr::select(host_ID,host_species,village,grid), by="host_ID")
# PSE - take into account phylogenetic distance and species abundance
# min value: 0; max value: 1
dat_phylo <- picante::pse(dat_phylo_matrix, rooted_tree)
dat_phylo %<>% rownames_to_column("host_ID") %>%
mutate(host_ID = as.numeric(host_ID)) %>%
left_join(dat %>% dplyr::select(host_ID,host_species,village,grid), by="host_ID")
richness <- dat_long %>% group_by( host_ID) %>%
summarise(richness = n_distinct(asv_ID))
dat_shannon <- dat %>%
dplyr::select(starts_with("ASV")) %>%
mutate(across(starts_with("ASV"),~ .*log(.)))
shannon <- -rowSums(dat_shannon, na.rm = TRUE)
# plotting
dat_phylo %>%
ggplot(aes(x=grid, y=shannon, fill=village)) +
facet_wrap(~host_species) +
geom_boxplot() +
theme_bw() +
theme(axis.text = element_text(size = 10, color = 'black', angle = 90, vjust = 0.5, hjust=1), title = element_text(size = 16), strip.text.x = element_text(size = 12)) +
labs(x="Land-use", y="Average phylogenetic Diversity")
# plotting
dat_phylo %>%
ggplot(aes(x=grid, y=PSEs, fill=village)) +
facet_wrap(~host_species) +
geom_boxplot() +
theme_bw() +
theme(axis.text = element_text(size = 10, color = 'black', angle = 90, vjust = 0.5, hjust=1), title = element_text(size = 16), strip.text.x = element_text(size = 12)) +
labs(x="Land-use", y="Average phylogenetic Diversity")
# combining all diversity measures into one data frame + hosts metadata
asv_diversity <- tibble(host_ID = richness$host_ID,
richness = richness$richness,
shannon = shannon,
phylo = dat_phylo$PSEs) %>%
left_join(data_sm, by="host_ID")
# transforming to long format
dat_long <- dat %>% gather("asv_ID","reads",starts_with("ASV")) %>%
filter(reads > 0)
richness <- dat_long %>% group_by( host_ID) %>%
summarise(richness = n_distinct(asv_ID))
# combining all diversity measures into one data frame + hosts metadata
asv_diversity <- tibble(host_ID = richness$host_ID,
richness = richness$richness,
shannon = shannon,
phylo = dat_phylo$PSEs) %>%
left_join(data_sm, by="host_ID")
install.packages(c("ape", "aricode", "askpass", "backports", "bayesm", "BiocManager", "bipartite", "boot", "brew", "brio", "broom", "bslib", "cachem", "callr", "class", "cli", "clue", "cluster", "coda", "codetools", "commonmark", "compositions", "cowplot", "cpp11", "credentials", "crosstalk", "curl", "data.table", "dbplyr", "DEoptimR", "desc", "digest", "dotCall64", "downlit", "dplyr", "DT", "ecodist", "ellipse", "emmeans", "estimability", "evaluate", "FactoMineR", "fansi", "farver", "fastmap", "fastmatch", "fBasics", "fields", "fitdistrplus", "fontawesome", "foreign", "fs", "gargle", "gert", "ggplot2", "ggrepel", "ggsci", "gh", "glue", "googledrive", "googlesheets4", "gss", "gtable", "GUniFrac", "haven", "htmltools", "htmlwidgets", "httpuv", "httr", "httr2", "igraph", "insight", "jsonlite", "KernSmooth", "knitr", "labeling", "later", "lattice", "lifecycle", "lme4", "lubridate", "maps", "markdown", "MatrixModels", "matrixStats", "mgcv", "minqa", "multcomp", "multcompView", "munsell", "mvtnorm", "network", "nlme", "nnet", "openssl", "pals", "pixmap", "pkgbuild", "pkgdown", "pkgload", "pls", "plyr", "prettyunits", "processx", "profvis", "progress", "promises", "ps", "purrr", "quantreg", "ragg", "Rcpp", "RcppArmadillo", "RcppEigen", "RCurl", "readr", "readxl", "rematch", "remotes", "reprex", "rlang", "rmarkdown", "robustbase", "roxygen2", "rpart", "rprojroot", "rstudioapi", "Rtsne", "RVAideMemoire", "rvest", "sandwich", "sass", "scales", "scatterplot3d", "segmented", "seqinr", "shiny", "sna", "sp", "spam", "spatial", "statnet.common", "stringi", "stringr", "survival", "sys", "systemfonts", "tensorA", "testthat", "textshaping", "TH.data", "tidyr", "tidyselect", "timechange", "timeDate", "timeSeries", "tinytex", "usethis", "utf8", "uuid", "vctrs", "vegan", "viridis", "viridisLite", "vroom", "waldo", "withr", "xfun", "xml2", "xopen", "yaml", "zip", "zoo"))
install.packages(c("ape", "aricode", "askpass", "backports", "bayesm", "BiocManager", "bipartite", "boot", "brew", "brio", "broom", "bslib", "cachem", "callr", "class", "cli", "clue", "cluster", "coda", "codetools", "commonmark", "compositions", "cowplot", "cpp11", "credentials", "crosstalk", "curl", "data.table", "dbplyr", "DEoptimR", "desc", "digest", "dotCall64", "downlit", "dplyr", "DT", "ecodist", "ellipse", "emmeans", "estimability", "evaluate", "FactoMineR", "fansi", "farver", "fastmap", "fastmatch", "fBasics", "fields", "fitdistrplus", "fontawesome", "foreign", "fs", "gargle", "gert", "ggplot2", "ggrepel", "ggsci", "gh", "glue", "googledrive", "googlesheets4", "gss", "gtable", "GUniFrac", "haven", "htmltools", "htmlwidgets", "httpuv", "httr", "httr2", "igraph", "insight", "jsonlite", "KernSmooth", "knitr", "labeling", "later", "lattice", "lifecycle", "lme4", "lubridate", "maps", "markdown", "MatrixModels", "matrixStats", "mgcv", "minqa", "multcomp", "multcompView", "munsell", "mvtnorm", "network", "nlme", "nnet", "openssl", "pals", "pixmap", "pkgbuild", "pkgdown", "pkgload", "pls", "plyr", "prettyunits", "processx", "profvis", "progress", "promises", "ps", "purrr", "quantreg", "ragg", "Rcpp", "RcppArmadillo", "RcppEigen", "RCurl", "readr", "readxl", "rematch", "remotes", "reprex", "rlang", "rmarkdown", "robustbase", "roxygen2", "rpart", "rprojroot", "rstudioapi", "Rtsne", "RVAideMemoire", "rvest", "sandwich", "sass", "scales", "scatterplot3d", "segmented", "seqinr", "shiny", "sna", "sp", "spam", "spatial", "statnet.common", "stringi", "stringr", "survival", "sys", "systemfonts", "tensorA", "testthat", "textshaping", "TH.data", "tidyr", "tidyselect", "timechange", "timeDate", "timeSeries", "tinytex", "usethis", "utf8", "uuid", "vctrs", "vegan", "viridis", "viridisLite", "vroom", "waldo", "withr", "xfun", "xml2", "xopen", "yaml", "zip", "zoo"))
install.packages(c("ape", "aricode", "askpass", "backports", "bayesm", "BiocManager", "bipartite", "boot", "brew", "brio", "broom", "bslib", "cachem", "callr", "class", "cli", "clue", "cluster", "coda", "codetools", "commonmark", "compositions", "cowplot", "cpp11", "credentials", "crosstalk", "curl", "data.table", "dbplyr", "DEoptimR", "desc", "digest", "dotCall64", "downlit", "dplyr", "DT", "ecodist", "ellipse", "emmeans", "estimability", "evaluate", "FactoMineR", "fansi", "farver", "fastmap", "fastmatch", "fBasics", "fields", "fitdistrplus", "fontawesome", "foreign", "fs", "gargle", "gert", "ggplot2", "ggrepel", "ggsci", "gh", "glue", "googledrive", "googlesheets4", "gss", "gtable", "GUniFrac", "haven", "htmltools", "htmlwidgets", "httpuv", "httr", "httr2", "igraph", "insight", "jsonlite", "KernSmooth", "knitr", "labeling", "later", "lattice", "lifecycle", "lme4", "lubridate", "maps", "markdown", "MatrixModels", "matrixStats", "mgcv", "minqa", "multcomp", "multcompView", "munsell", "mvtnorm", "network", "nlme", "nnet", "openssl", "pals", "pixmap", "pkgbuild", "pkgdown", "pkgload", "pls", "plyr", "prettyunits", "processx", "profvis", "progress", "promises", "ps", "purrr", "quantreg", "ragg", "Rcpp", "RcppArmadillo", "RcppEigen", "RCurl", "readr", "readxl", "rematch", "remotes", "reprex", "rlang", "rmarkdown", "robustbase", "roxygen2", "rpart", "rprojroot", "rstudioapi", "Rtsne", "RVAideMemoire", "rvest", "sandwich", "sass", "scales", "scatterplot3d", "segmented", "seqinr", "shiny", "sna", "sp", "spam", "spatial", "statnet.common", "stringi", "stringr", "survival", "sys", "systemfonts", "tensorA", "testthat", "textshaping", "TH.data", "tidyr", "tidyselect", "timechange", "timeDate", "timeSeries", "tinytex", "usethis", "utf8", "uuid", "vctrs", "vegan", "viridis", "viridisLite", "vroom", "waldo", "withr", "xfun", "xml2", "xopen", "yaml", "zip", "zoo"))
install.packages(c("ape", "aricode", "askpass", "backports", "bayesm", "BiocManager", "bipartite", "boot", "brew", "brio", "broom", "bslib", "cachem", "callr", "class", "cli", "clue", "cluster", "coda", "codetools", "commonmark", "compositions", "cowplot", "cpp11", "credentials", "crosstalk", "curl", "data.table", "dbplyr", "DEoptimR", "desc", "digest", "dotCall64", "downlit", "dplyr", "DT", "ecodist", "ellipse", "emmeans", "estimability", "evaluate", "FactoMineR", "fansi", "farver", "fastmap", "fastmatch", "fBasics", "fields", "fitdistrplus", "fontawesome", "foreign", "fs", "gargle", "gert", "ggplot2", "ggrepel", "ggsci", "gh", "glue", "googledrive", "googlesheets4", "gss", "gtable", "GUniFrac", "haven", "htmltools", "htmlwidgets", "httpuv", "httr", "httr2", "igraph", "insight", "jsonlite", "KernSmooth", "knitr", "labeling", "later", "lattice", "lifecycle", "lme4", "lubridate", "maps", "markdown", "MatrixModels", "matrixStats", "mgcv", "minqa", "multcomp", "multcompView", "munsell", "mvtnorm", "network", "nlme", "nnet", "openssl", "pals", "pixmap", "pkgbuild", "pkgdown", "pkgload", "pls", "plyr", "prettyunits", "processx", "profvis", "progress", "promises", "ps", "purrr", "quantreg", "ragg", "Rcpp", "RcppArmadillo", "RcppEigen", "RCurl", "readr", "readxl", "rematch", "remotes", "reprex", "rlang", "rmarkdown", "robustbase", "roxygen2", "rpart", "rprojroot", "rstudioapi", "Rtsne", "RVAideMemoire", "rvest", "sandwich", "sass", "scales", "scatterplot3d", "segmented", "seqinr", "shiny", "sna", "sp", "spam", "spatial", "statnet.common", "stringi", "stringr", "survival", "sys", "systemfonts", "tensorA", "testthat", "textshaping", "TH.data", "tidyr", "tidyselect", "timechange", "timeDate", "timeSeries", "tinytex", "usethis", "utf8", "uuid", "vctrs", "vegan", "viridis", "viridisLite", "vroom", "waldo", "withr", "xfun", "xml2", "xopen", "yaml", "zip", "zoo"))
install.packages(c("ape", "aricode", "askpass", "backports", "bayesm", "BiocManager", "bipartite", "boot", "brew", "brio", "broom", "bslib", "cachem", "callr", "class", "cli", "clue", "cluster", "coda", "codetools", "commonmark", "compositions", "cowplot", "cpp11", "credentials", "crosstalk", "curl", "data.table", "dbplyr", "DEoptimR", "desc", "digest", "dotCall64", "downlit", "dplyr", "DT", "ecodist", "ellipse", "emmeans", "estimability", "evaluate", "FactoMineR", "fansi", "farver", "fastmap", "fastmatch", "fBasics", "fields", "fitdistrplus", "fontawesome", "foreign", "fs", "gargle", "gert", "ggplot2", "ggrepel", "ggsci", "gh", "glue", "googledrive", "googlesheets4", "gss", "gtable", "GUniFrac", "haven", "htmltools", "htmlwidgets", "httpuv", "httr", "httr2", "igraph", "insight", "jsonlite", "KernSmooth", "knitr", "labeling", "later", "lattice", "lifecycle", "lme4", "lubridate", "maps", "markdown", "MatrixModels", "matrixStats", "mgcv", "minqa", "multcomp", "multcompView", "munsell", "mvtnorm", "network", "nlme", "nnet", "openssl", "pals", "pixmap", "pkgbuild", "pkgdown", "pkgload", "pls", "plyr", "prettyunits", "processx", "profvis", "progress", "promises", "ps", "purrr", "quantreg", "ragg", "Rcpp", "RcppArmadillo", "RcppEigen", "RCurl", "readr", "readxl", "rematch", "remotes", "reprex", "rlang", "rmarkdown", "robustbase", "roxygen2", "rpart", "rprojroot", "rstudioapi", "Rtsne", "RVAideMemoire", "rvest", "sandwich", "sass", "scales", "scatterplot3d", "segmented", "seqinr", "shiny", "sna", "sp", "spam", "spatial", "statnet.common", "stringi", "stringr", "survival", "sys", "systemfonts", "tensorA", "testthat", "textshaping", "TH.data", "tidyr", "tidyselect", "timechange", "timeDate", "timeSeries", "tinytex", "usethis", "utf8", "uuid", "vctrs", "vegan", "viridis", "viridisLite", "vroom", "waldo", "withr", "xfun", "xml2", "xopen", "yaml", "zip", "zoo"))
install.packages(c("ape", "aricode", "askpass", "backports", "bayesm", "BiocManager", "bipartite", "boot", "brew", "brio", "broom", "bslib", "cachem", "callr", "class", "cli", "clue", "cluster", "coda", "codetools", "commonmark", "compositions", "cowplot", "cpp11", "credentials", "crosstalk", "curl", "data.table", "dbplyr", "DEoptimR", "desc", "digest", "dotCall64", "downlit", "dplyr", "DT", "ecodist", "ellipse", "emmeans", "estimability", "evaluate", "FactoMineR", "fansi", "farver", "fastmap", "fastmatch", "fBasics", "fields", "fitdistrplus", "fontawesome", "foreign", "fs", "gargle", "gert", "ggplot2", "ggrepel", "ggsci", "gh", "glue", "googledrive", "googlesheets4", "gss", "gtable", "GUniFrac", "haven", "htmltools", "htmlwidgets", "httpuv", "httr", "httr2", "igraph", "insight", "jsonlite", "KernSmooth", "knitr", "labeling", "later", "lattice", "lifecycle", "lme4", "lubridate", "maps", "markdown", "MatrixModels", "matrixStats", "mgcv", "minqa", "multcomp", "multcompView", "munsell", "mvtnorm", "network", "nlme", "nnet", "openssl", "pals", "pixmap", "pkgbuild", "pkgdown", "pkgload", "pls", "plyr", "prettyunits", "processx", "profvis", "progress", "promises", "ps", "purrr", "quantreg", "ragg", "Rcpp", "RcppArmadillo", "RcppEigen", "RCurl", "readr", "readxl", "rematch", "remotes", "reprex", "rlang", "rmarkdown", "robustbase", "roxygen2", "rpart", "rprojroot", "rstudioapi", "Rtsne", "RVAideMemoire", "rvest", "sandwich", "sass", "scales", "scatterplot3d", "segmented", "seqinr", "shiny", "sna", "sp", "spam", "spatial", "statnet.common", "stringi", "stringr", "survival", "sys", "systemfonts", "tensorA", "testthat", "textshaping", "TH.data", "tidyr", "tidyselect", "timechange", "timeDate", "timeSeries", "tinytex", "usethis", "utf8", "uuid", "vctrs", "vegan", "viridis", "viridisLite", "vroom", "waldo", "withr", "xfun", "xml2", "xopen", "yaml", "zip", "zoo"))
install.packages(c("ape", "aricode", "askpass", "backports", "bayesm", "BiocManager", "bipartite", "boot", "brew", "brio", "broom", "bslib", "cachem", "callr", "class", "cli", "clue", "cluster", "coda", "codetools", "commonmark", "compositions", "cowplot", "cpp11", "credentials", "crosstalk", "curl", "data.table", "dbplyr", "DEoptimR", "desc", "digest", "dotCall64", "downlit", "dplyr", "DT", "ecodist", "ellipse", "emmeans", "estimability", "evaluate", "FactoMineR", "fansi", "farver", "fastmap", "fastmatch", "fBasics", "fields", "fitdistrplus", "fontawesome", "foreign", "fs", "gargle", "gert", "ggplot2", "ggrepel", "ggsci", "gh", "glue", "googledrive", "googlesheets4", "gss", "gtable", "GUniFrac", "haven", "htmltools", "htmlwidgets", "httpuv", "httr", "httr2", "igraph", "insight", "jsonlite", "KernSmooth", "knitr", "labeling", "later", "lattice", "lifecycle", "lme4", "lubridate", "maps", "markdown", "MatrixModels", "matrixStats", "mgcv", "minqa", "multcomp", "multcompView", "munsell", "mvtnorm", "network", "nlme", "nnet", "openssl", "pals", "pixmap", "pkgbuild", "pkgdown", "pkgload", "pls", "plyr", "prettyunits", "processx", "profvis", "progress", "promises", "ps", "purrr", "quantreg", "ragg", "Rcpp", "RcppArmadillo", "RcppEigen", "RCurl", "readr", "readxl", "rematch", "remotes", "reprex", "rlang", "rmarkdown", "robustbase", "roxygen2", "rpart", "rprojroot", "rstudioapi", "Rtsne", "RVAideMemoire", "rvest", "sandwich", "sass", "scales", "scatterplot3d", "segmented", "seqinr", "shiny", "sna", "sp", "spam", "spatial", "statnet.common", "stringi", "stringr", "survival", "sys", "systemfonts", "tensorA", "testthat", "textshaping", "TH.data", "tidyr", "tidyselect", "timechange", "timeDate", "timeSeries", "tinytex", "usethis", "utf8", "uuid", "vctrs", "vegan", "viridis", "viridisLite", "vroom", "waldo", "withr", "xfun", "xml2", "xopen", "yaml", "zip", "zoo"))
library(tidyverse)
library(dplyr)
library(magrittr)
library(ape)
library(adegenet)
library(phangorn)
# aligning the sequences
seq_aligned <- readDNAStringSet("data/data_raw/data_microbiome/ASV_filtered_new.fa")
library(BiocGenerics)
aligned <- DECIPHER::AlignSeqs(seq_aligned)
# aligning the sequences
seq_aligned <- readDNAStringSet("data/data_raw/data_microbiome/ASV_filtered_new.fa")
detach("package:BiocGenerics", unload = TRUE)
library(Biostrings)
# aligning the sequences
seq_aligned <- readDNAStringSet("data/data_raw/data_microbiome/ASV_filtered_new.fa")
setwd("~/Documents/GitHub/Microbiome_Structure_Madagascar")
# aligning the sequences
seq_aligned <- readDNAStringSet("data/data_raw/data_microbiome/ASV_filtered_new.fa")
aligned <- DECIPHER::AlignSeqs(seq_aligned)
View(aligned)
seq_aligned2 <- as.DNAbin(aligned)
View(seq_aligned2)
asv_distance <- ape::dist.dna(seq_aligned2)
asv_distance <- as.matrix(ape::dist.dna(seq_aligned2))
View(asv_distance)
# reading small mammals data
data_mammals <- read_csv("data/data_raw/data_small_mammals/Terrestrial_Mammals.csv")
>>>>>>> 635f49f0a1705f2767ea97c80d1b0fdb2663b6fb
