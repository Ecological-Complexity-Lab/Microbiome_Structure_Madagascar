---
title: "Land use and microbe prevalence jointly determine host-microbe network structure"
subtitle: "Analysis and results"
author: "Matan Markfeld"
date: "Last edit: 2024-06-09"
output: 
  html_document:
    toc: true
    toc_float: true
    collapse: false
    number_sections: true
    code_folding: hide
    highlight: tango
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(results = "asis", message=FALSE, warning=FALSE, cache=TRUE, eval = TRUE, dev = c('png'), out.width = '100%', out.height='60%')
```


```{r load libraries, echo=FALSE, message=FALSE, warning=FALSE}
library(tidyverse)
library(magrittr)
library(ggplot2)
library(vegan)
library(igraph)
library(reshape2)
library(infomapecology)
library(aricode)
library(ape)
library(picante)
library(patchwork)

rm(list=ls())
```

```{r}
source("modularity_analysis_functions.R", local = knitr::knit_global())
```

```{r, microbiome data}
# reading the microbiome data
# working only with Rattus from the three villages

# villages: Andatsakala, Mandena, Sarahandrano
vil <- "Mandena"
data_asv <- read_csv("../data/data_processed/microbiome/data_asv_rra0.001_p0.01_th5000.csv") %>% filter(village == vil)
```

```{r, main analysis, include=FALSE, results='hide'}
# first of all, run this chunk of code.
# this code does all the modularity analysis using the functions in "modularity_analysis_functions".
# There is a loop runs for the three villages, and all the analysis is done separately for each village.
# the output of the code is variables holding the final results tables and figures (the output of the functions used)

# setting thresholds for core
core_th <- c(0.02, 0.2)
data_asv %<>% mutate(asv_core = case_when(host_p<core_th[1] ~ "Rare",
                                          host_p>core_th[2] ~ "Core",
                                          .default = "Non_core"))

# # updating reads per core group
# reads_new <- data_asv %>% 
#   group_by(host_ID, asv_core) %>% 
#   summarise(total_reads = sum(reads*total_reads))
# 
# data_asv2 = data_asv %>%  mutate(reads = reads*total_reads) %>% 
#   select(-total_reads) %>% 
#   left_join(reads_new, by=c("host_ID","asv_core")) %>% 
#   mutate(reads = reads/total_reads)

group.colors <- c(Core = "#e76f51", Non_core = "#2b9348", Rare = "#0077b6")

core_names <- unique(data_asv$asv_core)
nmi_observed_three_groups <- NULL
modules_similarity_three_groups <- NULL
asv_degree_distribution_three_groups <- NULL
modules_three_groups <- NULL
modules_size_three_groups <- NULL
modules_grid_three_groups <- NULL
modules_table_three_groups <- NULL
betaNTI_three_groups <- NULL
raupc_three_groups <- NULL

# reading the phylogenetic tree
best_tree <- readRDS(file = "../results/phylo_tree_rra0.001_p0.01.rds")
phylo_tree <- best_tree$tree 
# ASVs phylogenetic distance
asv_distance <- ape::cophenetic.phylo(phylo_tree)

# loop for three groups
for (v in core_names) {
  
  data_asv_group <- data_asv %>% 
    filter(asv_core == v)
  
  # calculating ASVs degree
  asv_degree <- data_asv_group %>%
    group_by(asv_ID) %>%
    summarise(n = n_distinct(host_ID)) %>%
    dplyr::rename(asv_degree = n)
  data_asv_group %<>% left_join(asv_degree, by="asv_ID")
  
  ##### observed network
  # finding modules
  modules_observed <- fun_modularity_analysis(data_asv_group)
  modules_table_three_groups <- rbind(modules_table_three_groups, modules_observed)
  #write_csv(modules_table_three_groups, "../results/modules_table_three_villages.csv")
  
  # calculating similarity in modules between grids
  modules_similarity <- fun_modules_similarity(modules_observed)
  # saving results in one table
  modules_similarity_three_groups <- append(modules_similarity_three_groups, modules_similarity)
  
  # ASVs degree distribution
  asv_degree_distribution <- fun_asv_degree_distribution(data_asv_group)
  asv_degree_distribution_three_groups <- append(asv_degree_distribution_three_groups, asv_degree_distribution)
  
  # figure of modules 
  modules <- fun_modules(modules_observed)
  modules_three_groups <- append(modules_three_groups, modules)
  
  # modules size
  modules_size <- fun_module_size(modules_observed)
  modules_size_three_groups <- append(modules_size_three_groups, modules_size)
  
  # Number of land uses per module
  modules_grid <- fun_module_grid(modules_observed)
  modules_grid_three_groups <- append(modules_grid_three_groups, modules_grid)
  
  # calculating NMI
  nmi_observed <- fun_nmi_calc(modules_observed, TRUE)
  # saving results in one list
  nmi_observed_three_groups <- append(nmi_observed_three_groups, nmi_observed)
  
  
  ##### phylogenetic analysis
  # ASVs pool
  asv_pool <- data_asv_group %>% 
    distinct(asv_ID, asv_degree) %>% 
    mutate(p = asv_degree/length(unique(data_asv_group$asv_ID)))
  
  # calculating betaNTI
  data_betaNTI <- data_asv_group %>% 
    distinct(host_ID, asv_ID) %>% 
    mutate(reads = 1) %>% 
    spread(asv_ID, reads, fill = 0) %>% 
    column_to_rownames("host_ID") %>% 
    as.matrix()
  
  betaNTI <- fun_calc_betaNTI(data_betaNTI, asv_distance, asv_pool) %>% 
    left_join(modules_observed %>% distinct(host_ID, host_group, grid), by=c("host1"="host_ID")) %>% dplyr::rename(host_group1=host_group, grid1=grid) %>% 
    left_join(modules_observed %>% distinct(host_ID, host_group, grid), by=c("host2"="host_ID")) %>% dplyr::rename(host_group2=host_group, grid2=grid) %>% 
    mutate(asv_core = v)
  betaNTI_three_groups <- rbind(betaNTI_three_groups, betaNTI)
  
  # raup-crick
  raupc <- raupcrick(data_betaNTI)
  raupc2 <- as.matrix(raupc) 
  raupc2[upper.tri(raupc2)] <- NA
  diag(raupc2) <- NA
  raupc2_m <- melt(raupc2) %>% 
    filter(!(is.na(value)))%>% 
    dplyr::rename(host1 = Var1, host2 = Var2, raupc = value) %>% 
    left_join(modules_observed %>% distinct(host_ID, host_group, grid), by=c("host1"="host_ID")) %>% dplyr::rename(host_group1=host_group, grid1=grid) %>% 
    left_join(modules_observed %>% distinct(host_ID, host_group, grid), by=c("host2"="host_ID")) %>% dplyr::rename(host_group2=host_group, grid2=grid) %>% 
    mutate(asv_core = v)
  raupc_three_groups <- rbind(raupc_three_groups, raupc2_m)
}
```

# Exploration {.tabset}

```{r, sm exploration}
# small mammals data
small_mammals <- read_csv("../data/data_raw/data_small_mammals/Terrestrial_Mammals.csv") %>% 
  mutate(host_ID = as.numeric(gsub(".*?([0-9]+).*", "\\1", animal_id))) %>% 
  mutate(age_repro = as_factor(age_repro)) %>% 
  rename(grid = habitat_type) %>% 
  filter(host_ID %in% data_asv$host_ID)

cat("## Abundance", '\n','\n')
g <- small_mammals %>% 
  count(grid) %>% 
  ggplot(aes(x=grid, y=n)) +
  geom_bar(position="dodge", stat="identity") +
  theme_bw() +
  theme(axis.text = element_text(size = 10, color = 'black', angle = 90, vjust = 0.5, hjust=1), title = element_text(size = 14)) +
  labs(x="Land Use", y="Small-Mammals Abundance")
print(g)

cat("## Sex ratio", '\n','\n')
g <- small_mammals %>% 
  count(grid, sex) %>% 
  ggplot(aes(fill=sex, x=grid, y=n)) +
  geom_bar(position="fill", stat="identity") +
  geom_hline(yintercept = 0.5, linetype = "dashed") +
  theme_bw() +
  theme(axis.text = element_text(size = 10, color = 'black', angle = 90, vjust = 0.5, hjust=1), title = element_text(size = 14)) +
  labs(x="Land Use", y="Proportion")
print(g)

cat("## Age ratio", '\n','\n')
g <- small_mammals %>% 
  count(grid, age_repro) %>% 
  ggplot(aes(fill=age_repro, x=grid, y=n)) +
  geom_bar(position="fill", stat="identity") +
  theme_bw() +
  theme(axis.text = element_text(size = 10, color = 'black', angle = 90, vjust = 0.5, hjust=1), title = element_text(size = 14)) +
  labs(x="Land Use", y="Proportion")
print(g)
```


```{r, microbiome exploration}

# relative abundance
s <- data_asv %>% 
  group_by(village, asv_ID) %>% 
  summarise(n=mean(reads)) %>% 
  group_by(village) %>% 
  summarise(mean=mean(n), median=median(n), sd=sd(n), max=max(n))

# microbes taxonomy
tax <- read_delim("../data/data_raw/data_microbiome/ASVs_taxonomy_new.tsv") %>% 
  dplyr::rename(asv_ID = ASV)

data_asv_tax <- data_asv %>% 
  left_join(tax, by="asv_ID")

tax_uni <- tax %>% filter(asv_ID %in% unique(data_asv$asv_ID)) %>% 
  count(Phylum,Family)


cat("## Relative abundance", '\n','\n')
total_reads_groups_grid <- data_asv_tax %>% mutate(reads_a = reads*total_reads) %>%  group_by(asv_core, grid) %>% summarise(n_total = sum(reads_a))
g <- data_asv_tax %>% 
  mutate(reads_a = reads*total_reads) %>% 
  group_by(asv_core, grid, Phylum) %>% 
  summarise(n= sum(reads_a)) %>% 
  left_join(total_reads_groups_grid, by=c("asv_core","grid")) %>% 
  mutate(n_p = n/n_total) %>% 
  ggplot(aes(fill=Phylum, x=grid, y=n_p)) +
  geom_bar(position="fill", stat="identity") +
  facet_wrap(~asv_core) +
  theme_bw() +
  theme(axis.text = element_text(size = 10, color = 'black', angle = 90, vjust = 0.5, hjust=1), title = element_text(size = 14)) +
  labs(x="Land Use", y="Relative abundance")
print(g)

cat("## No. of species", '\n','\n')
g <- data_asv_tax %>% 
  count(asv_core, grid, asv_ID, Phylum) %>%
  group_by(asv_core, grid, Phylum) %>% 
  summarise(n_asv= n_distinct(asv_ID)) %>% 
  ggplot(aes(fill=Phylum, x=grid, y=n_asv)) +
  geom_bar(position="fill", stat="identity") +
  facet_wrap(~asv_core) +
  theme_bw() +
  theme(axis.text = element_text(size = 10, color = 'black', angle = 90, vjust = 0.5, hjust=1), title = element_text(size = 14)) +
  labs(x="Land Use", y="Proportion No. of ASVs")
print(g)


cat("## Relative abundance Family", '\n','\n')
total_reads_groups <- data_asv_tax %>% distinct(host_ID, asv_core, total_reads) %>% group_by(asv_core) %>% summarise(n_total = sum(total_reads))
most_abu_family <- data_asv_tax %>%
  mutate(reads_a = reads*total_reads) %>%
  group_by(asv_core, Family, grid) %>%
  summarise(n= sum(reads_a)) %>%
  left_join(total_reads_groups, by="asv_core") %>%
  mutate(n_p = n/n_total) 

  most_abu_family_8 <- most_abu_family %>% 
    filter(!is.na(Family)) %>% 
    ungroup() %>% 
    slice_max(by = asv_core, order_by = n_p, n = 8) %>% 
    mutate(p = "top") %>% 
    select(asv_core, Family, p)
  
  most_abu_family_p <- most_abu_family %>% 
    left_join(most_abu_family_8, by=c("asv_core","Family")) %>% 
    mutate(p = case_when(p=="top" ~ Family,
                         is.na(Family) ~ "NA",
                         is.na(p) ~ "Other"))

  most_abu_family_p %>% 
    group_by(asv_core,  p) %>% 
    summarise(n_p = sum(n_p)) %>% 
ggplot(aes(fill=p, x=asv_core, y=n_p)) +
  geom_bar(position="fill", stat="identity") +
  #facet_wrap(~asv_core) +
  theme_bw() +
  theme(axis.text = element_text(size = 10, color = 'black', angle = 90, vjust = 0.5, hjust=1), title = element_text(size = 14)) +
  labs(x="Land Use", y="Relative abundance")
print(most_abu_family)
```


# Network exploration {.tabset}


```{r, network_exploration}
# loop for three groups
for (i in 1:3) {
  
  cat('##',core_names[i],'{.tabset}','\n','\n')
  
  cat('### ASVs degree distribution','\n')
  
  print(asv_degree_distribution_three_groups[[i]])
  cat('\n','\n')
  
  # calculating connectance
  connectance_data <- modules_table_three_groups %>% 
    filter(asv_core == core_names[i])
  
  cat('No. of hosts: ', length(unique(connectance_data$host_ID)) ,'\n','\n')
  cat('No. of ASVs: ', length(unique(connectance_data$asv_ID)) ,'\n','\n')
  cat('Connectance: ', nrow(connectance_data) / (length(unique(connectance_data$host_ID)) * length(unique(connectance_data$asv_ID))) ,'\n','\n')
  
  
  cat('### Modules','\n')
  cat('The color indicates number of host individuals in the module / total number of hosts in the whole grid [%]','\n','\n')
  
  print(modules_three_groups[[i]])
  cat('\n','\n')
  
  cat('### Modules size','\n')
  print(modules_size_three_groups[[i]])
  cat('\n','\n')
  
  cat('### No. of land uses','\n')
  print(modules_grid_three_groups[[i]])
  cat('\n','\n')
  
}

cat('## Modules size','{.tabset}','\n','\n')

g <- modules_table_three_groups %>% 
  group_by(asv_core, host_group) %>% 
  summarise(n = n_distinct(host_ID)) %>% 
  ggplot(aes(x=asv_core, y=n, fill=asv_core)) + 
  geom_violin() +
  theme_classic() +
  #scale_y_continuous(limits = c(0, 50)) +
  theme(axis.text = element_text(size = 12, color = 'black'), title = element_text(size = 15), legend.position = "none") +
  scale_fill_manual(values=group.colors) +
  labs(x="ASV Group", y="Module Size")
print(g)

cat('## Modules grid','{.tabset}','\n','\n')

g <- modules_table_three_groups %>% 
  group_by(asv_core, host_group) %>% 
  summarise(n = n_distinct(grid)) %>% 
  ggplot(aes(x=asv_core, y=n, fill=asv_core)) + 
  geom_violin() +
  theme_classic() +
  #scale_y_continuous(limits = c(0, 50)) +
  theme(axis.text = element_text(size = 12, color = 'black'), title = element_text(size = 15), legend.position = "none") +
  scale_fill_manual(values=group.colors) +
  labs(x="ASV Group", y="No. of Land uses")
print(g)

```

```{r, groups_modules}
host_module_partners <- function(dat, hosts) {
  
  group_similarity_all <- NULL
  for (h in hosts) {
    
    # the modules of the focal host
    h_module <- dat %>% filter(host_ID==h) %>% select(-host_ID) %>% mutate(s=T)
    # taking only the module partners of the focal host
    dat_module <- dat %>% 
      left_join(h_module, by=c("asv_core","host_group")) %>% 
      filter(s) %>% 
      select(asv_core, host_ID) %>% 
      mutate(n=1, host_ID = as.character(host_ID)) %>% 
      spread(host_ID, n, fill=0) %>% 
      column_to_rownames("asv_core") %>% 
      as.matrix()
    
    # removing the focal host from the table
    #dat_module <- dat_module[, colnames(dat_module)!=h]
    
    # calculating similarity
    group_similarity <- as.matrix(1-vegdist(dat_module, method = "jaccard"))
    group_similarity[upper.tri(group_similarity)] <- NA
    diag(group_similarity) <- NA
    group_similarity_m <- melt(group_similarity) %>% 
    filter(!(is.na(value))) %>% 
      mutate(host_ID = h)
    
    group_similarity_all <- rbind(group_similarity_all, group_similarity_m)
  }
  
  # calculating the mean
  group_similarity_mean <- group_similarity_all %>% 
    unite("groups", Var1:Var2) %>%
    group_by(groups) %>% 
    summarise(mean = mean(value), median = median(value), sd = sd(value))
    
  return(group_similarity_mean)
}


host_modules <- modules_table_three_groups %>% 
  distinct(asv_core, host_ID, host_group)

host_list <- unique(host_modules$host_ID)

# observed results
groups_sim_obs <- host_module_partners(host_modules, host_list)

# shuffle modules membership
groups_sim_shuff_all <- NULL
for(i in 1:20) {
host_modules_shuff <- host_modules %>% 
      group_by(asv_core) %>%
      mutate(host_group = sample(host_group))

groups_sim_shuff <- host_module_partners(host_modules_shuff, host_list)
groups_sim_shuff_all <- rbind(groups_sim_shuff_all, groups_sim_shuff)
}

# plotting
g <- groups_sim_shuff_all %>% 
  ggplot(aes(x=mean, group=groups, fill=groups)) +
    geom_histogram() +
  geom_vline(data=groups_sim_obs, aes(xintercept = mean), linetype='dashed', color="black") +
    facet_wrap(~groups) +
   theme_bw() +
    theme(
      legend.position="none",
      panel.spacing = unit(0.1, "lines")
    )
print(g)
```

# Phylogenetic analysis

```{r}

# beta-NTI same module?
betaNTI_final <- betaNTI_three_groups %>% 
  mutate(same_module = ifelse(host_group1==host_group2, "Same","Different")) 



# Raup-Crick same module?
raupc_final <- raupc_three_groups %>% 
  mutate(same_module = ifelse(host_group1==host_group2, "Same","Different"))

```

```{r, assembly_processes}
# combining final results
assembly_final <- betaNTI_final %>% 
  full_join(raupc_final %>% dplyr::select(host1,host2,raupc,asv_core), by=c("host1","host2","asv_core"))

a=assembly_final %>% filter(is.na(betaNTI))

# calculating the process
assembly_final %<>% mutate(process = case_when(betaNTI>2 ~ "Heterogeneous Selection",
                                               betaNTI<(-2) ~ "Homogeneous Selection",
                                               (betaNTI<=2 & betaNTI>=(-2) & raupc>0.95) ~ "Dispersal Limitation",
                                               (betaNTI<=2 & betaNTI>=(-2) & raupc<(-0.95)) ~ "Homogenizing Dispersal",
                                               .default = "Drift"))

# summary
assembly_summary <- assembly_final %>% 
  count(asv_core, same_module, process)

#plotting
g <- assembly_summary %>% 
  ggplot(aes(fill=process, x=same_module, y=n)) +
  geom_bar(position="fill", stat="identity") +
  facet_wrap(~asv_core) +
  theme_bw() +
  theme(axis.text = element_text(size = 10, color = 'black', angle = 90, vjust = 0.5, hjust=1), title = element_text(size = 14)) +
  labs(x="", y="Proportion")
print(g)
```


# Normalized Mutual Information (NMI) 

```{r, nmi}
cat('## Observed NMI','\n')

# making a data frame out of the shuffled results
# loop for three villages
nmi_observed_df_tv <- NULL
for (j in 1:3) {
  nmi_observed_df <- data_frame(nmi = nmi_observed_three_groups[[j*2]]) %>% 
    mutate(asv_core = core_names[j])
  nmi_observed_df_tv <- rbind(nmi_observed_df_tv, nmi_observed_df)
}

# making a data frame out of the observed results
nmi_observed_three_groups_df <- nmi_observed_three_groups[[1]] %>% 
  bind_rows(nmi_observed_three_groups[[3]]) %>% 
  bind_rows(nmi_observed_three_groups[[5]]) %>% 
  mutate(asv_core = core_names)

g <- nmi_observed_df_tv %>% 
  ggplot(aes(nmi, fill=asv_core)) + 
  geom_histogram(alpha=0.8, color="white") + 
  facet_wrap(~asv_core, scales="free") +
  scale_y_continuous(limits = c(0, 100)) +
  geom_vline(data=nmi_observed_three_groups_df, aes(xintercept = nmi), linetype='dashed', color="black") +
  geom_label(data = nmi_observed_three_groups_df, aes(label = paste("NMI =", round(nmi,2)), x = Inf, y = Inf),
             vjust = 1.5,hjust = 1.1, size = 4, color = "black", fill="white") +
  theme_bw() +
  
  theme(axis.text = element_text(size = 10, color = 'black'), title = element_text(size = 14), strip.text = element_text(size=12), panel.grid = element_blank(), legend.position="none") +
  scale_y_continuous(expand = expansion(mult = c(0.01, 0.01))) +
  scale_fill_manual(values=group.colors) +
  labs(x="Normalized Mutual Information (NMI)", y="Count")
print(g)
cat('\n','\n')

```

# Modules similarity across land use change gradient


## Correlations between variables

Distance is a proxy for habitat degradation.

```{r, variables_correlation}
# reading grid similarity results
grids_similarity_attr <- read_csv("../data/data_processed/village_summary.csv")

# correlations between variables
# loop for three villages
library(psych)
print(psych::pairs.panels(grids_similarity_attr %>% filter(village == vil) %>%  select(-village,-grid1,-grid2), ellipses = F, lm = T))
cat('\n','\n')
```



## Mantel test

```{r, mantel_test}
# mantel test for: modules similarity ~ distance between grids

# distance between grids matrices
load("../data/data_processed/distance_three_villages.RData")
names(grid_distance_three_villages) <- c("Mandena", "Sarahandrano", "Andatsakala")
grid_distance <- grid_distance_three_villages[[vil]]

mantel_result_three_groups <- NULL
final_data_three_groups <- NULL

# loop for three asv groups
for (i in 1:3) {
  
  modules_similarity <- modules_similarity_three_groups[[i]]
  grid_names <- rownames(modules_similarity)
  # filtering the distance matrix to the existing grids
  grid_distance <- grid_distance[grid_names, grid_names]
  
  # calculating mantel test
  mantel_result <- vegan::mantel(modules_similarity, grid_distance)
  mantel_result_df <- data_frame(r = round(mantel_result$statistic,2),
                                 pvalue = round(1-mantel_result$signif,4),
                                 asv_core = core_names[i])
  mantel_result_three_groups <- rbind(mantel_result_three_groups, mantel_result_df)
  
  
  # transforming to long format
  modules_similarity_m <- modules_similarity
  modules_similarity_m[lower.tri(modules_similarity_m)] <- NA
  diag(modules_similarity_m) <- NA
  final_data <- melt(modules_similarity_m) %>% 
    filter(!is.na(value)) %>% 
    mutate(asv_core = core_names[i]) %>% 
    dplyr::rename(grid1 = Var2, grid2 = Var1, module_similarity = value) %>% 
    left_join(grids_similarity_attr %>% filter(village == vil), by=c("grid1","grid2"))
  
  final_data_three_groups <- rbind(final_data_three_groups, final_data)
  
}

# plotting
g <- final_data_three_groups %>% 
  ggplot(aes(y=module_similarity, x=grid_dist, color = asv_core)) +
  geom_point(alpha = 0.8) +
  facet_wrap(~asv_core, scales="free")+
  scale_y_continuous(limits = c(0.0, 0.9)) +
  geom_smooth(method = "glm", se=T, method.args = list(family = "gaussian")) +
  geom_text(data = mantel_result_three_groups, aes(label = paste("r =", r), x = Inf, y = Inf),
            hjust = 1.3, vjust = 1.5, size = 4, color = "black") +
  geom_text(data = mantel_result_three_groups, aes(label = paste("p-value =", pvalue), x = Inf, y = Inf),
            hjust = 1.1, vjust = 3, size = 4, color = "black") +
  theme_bw() +
  theme(axis.text = element_text(size = 10, color = 'black'), title = element_text(size = 14), strip.text.x = element_text(size=12),
        panel.grid = element_blank(), legend.position = "none", panel.border = element_rect(color = "black")) +
  scale_color_manual(values=group.colors) +
  labs(x = "Distance Between Land Uses [m]", y = "Modules Similarity [Bray-Curtis]")
print(g)
cat('\n','\n')
```

# Link prediction {.tabset}

```{r, eval=FALSE, include=FALSE}
library(caret)
library(yardstick)

# reading the ML results files
test_set <- read_csv("link_prediction/test_set.csv")
feature_importance <- read_csv("link_prediction/feature_importance.csv")

# setting a threshold for prediction
th <- 0.5
test_set_predict <- test_set %>% 
  select(y_true, y_proba) %>% 
  mutate(y_proba_th = ifelse(y_proba >= th, 1, 0)) %>% 
  mutate(predict = ifelse(y_true == y_proba_th, 1, 0)) %>% 
  mutate(y_proba_th = factor(y_proba_th, levels = c(1,0)), y_true = factor(y_true, levels = c(1,0)))

cat('## Metrics','\n','\n')

conf_matrix <- caret::confusionMatrix(data=test_set_predict$y_proba_th, reference = test_set_predict$y_true, dnn = c("Prediction", "Reference"))
print(knitr::kable(conf_matrix$table))
cat('\n','\n')

accuracy <- conf_matrix$overall['Accuracy']
cat("Accuracy: ", round(accuracy, 4), '\n')
precision <- conf_matrix$byClass['Precision']
cat("Precision: ", round(precision, 4), '\n')
recall <- conf_matrix$byClass['Sensitivity']
cat("Recall: ", round(recall, 4), '\n')
f1_score <- 2 * (precision * recall) / (precision + recall)
cat("F1_score: ", round(f1_score, 4), '\n','\n')

cat('## ROC curve','\n','\n')

auc_roc_score <- yardstick::roc_auc(test_set_predict, y_true, y_proba)
roc_obj <- yardstick::roc_curve(test_set_predict, y_true, y_proba) %>% 
  ggplot(aes(x = 1 - specificity, y = sensitivity)) +
  geom_path(color = "blue") +
  geom_abline(lty = 3) +
  coord_equal() +
  theme_bw() +
  theme(plot.title = element_text(hjust = 0.5), plot.subtitle = element_text(hjust = 0.5))+
  labs(title = "ROC Curve", subtitle = paste("AUC = ", round(auc_roc_score$.estimate,3)))
print(roc_obj)
cat('\n','\n')

cat('## Precision-Recall curve','\n','\n')

auc_pr_score <- yardstick::pr_auc(test_set_predict, y_true, y_proba)
pr_obj <- yardstick::pr_curve(test_set_predict, y_true, y_proba) %>% 
  ggplot(aes(x = recall, y = precision)) +
  geom_path(color = "blue") +
  coord_equal() +
  theme_bw() +
  theme(plot.title = element_text(hjust = 0.5), plot.subtitle = element_text(hjust = 0.5))+
  labs(title = "Precision-Recall curve", subtitle = paste("AUC = ", round(auc_pr_score$.estimate,3)))
print(pr_obj)
cat('\n','\n')

cat('## Features importance','\n','\n')

feature_imp_g <- feature_importance %>% 
  arrange(value) %>% 
  mutate(feature = factor(feature, levels = feature)) %>% 
  ggplot(aes(x=feature, y=value)) +
  geom_bar(stat = "identity") +
  coord_flip()+
  scale_y_continuous(limits = c(0, 1)) +
  theme_bw() +
  theme(axis.text = element_text(size = 14, color = 'black'), title = element_text(size = 20), 
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank()) +
  labs(x="", y="Importance")
print(feature_imp_g)
cat('\n','\n')
```




