---
title: "Land use and microbe prevalence jointly determine host-microbe network structure"
subtitle: "Analysis and results"
author: "Matan Markfeld"
date: "Last edit: 2024-04-16"
output: 
  html_document:
    toc: true
    toc_float: true
    collapse: false
    number_sections: true
    code_folding: hide
    highlight: tango
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(results = "asis", message=FALSE, warning=FALSE, cache=TRUE, eval = TRUE, dev = c('png'), out.width = '100%', out.height='40%')
```


```{r load libraries, echo=FALSE, message=FALSE, warning=FALSE}
library(tidyverse)
library(magrittr)
library(ggplot2)
library(vegan)
library(igraph)
library(reshape2)
library(infomapecology)
library(aricode)
library(ape)
library(picante)

rm(list=ls())
```

```{r}
source("modularity_analysis_functions.R", local = knitr::knit_global())
```

```{r, microbiome data}
# reading the microbiome data
# working only with Rattus from the three villages

data_asv <- read_csv("../data/data_processed/microbiome/data_asv_rra0.01_th1000.csv") %>% 
  filter(host_species == "Rattus rattus")
```

```{r, main analysis, include=FALSE, results='hide'}
# first of all, run this chunk of code.
# this code does all the modularity analysis using the functions in "modularity_analysis_functions".
# There is a loop runs for the three villages, and all the analysis is done separately for each village.
# the output of the code is variables holding the final results tables and figures (the output of the functions used)

# setting thresholds for core
core_seq <- seq(1,20, by=1)

village_names <- unique(data_asv$village)
nmi_observed_three_villages <- NULL
nmi_diff_core_three_villages <- NULL
modules_similarity_three_villages <- NULL
asv_degree_distribution_three_villages <- NULL
modules_three_villages <- NULL
modules_size_three_villages <- NULL
modules_grid_three_villages <- NULL
modules_table_three_villages <- NULL
betaNTI_three_villages <- NULL
raupc_three_villages <- NULL

# reading the phylogenetic tree
best_tree <- readRDS(file = "../results/phylo_tree_0.01_2.rds")
phylo_tree <- best_tree$tree
# ASVs phylogenetic distance
asv_distance <- ape::cophenetic.phylo(phylo_tree)

# for loop for three villages
for (v in village_names) {
  
  data_asv_village <- data_asv %>% 
    filter(village == v)
  
  # calculating ASVs degree 
  asv_degree <- data_asv_village %>% 
    group_by(asv_ID) %>% 
    summarise(n = n_distinct(host_ID)) %>% 
    rename(asv_degree = n)
  data_asv_village %<>% left_join(asv_degree, by="asv_ID")
  
  ##### observed network
  # finding modules
  modules_observed <- fun_modularity_analysis(data_asv_village)
  modules_table_three_villages <- rbind(modules_table_three_villages, modules_observed)
  #write_csv(modules_table_three_villages, "../results/modules_table_three_villages.csv")
  
  # calculating similarity in modules between grids
  modules_similarity <- fun_modules_similarity(modules_observed)
  # saving results in one table
  modules_similarity_three_villages <- append(modules_similarity_three_villages, modules_similarity)
  
  # ASVs degree distribution
  asv_degree_distribution <- fun_asv_degree_distribution(data_asv_village)
  asv_degree_distribution_three_villages <- append(asv_degree_distribution_three_villages, asv_degree_distribution)
  
  # figure of modules 
  modules <- fun_modules(modules_observed)
  modules_three_villages <- append(modules_three_villages, modules)
  
  # modules size
  modules_size <- fun_module_size(modules_observed)
  modules_size_three_villages <- append(modules_size_three_villages, modules_size)
  
  # Number of land uses per module
  modules_grid <- fun_module_grid(modules_observed)
  modules_grid_three_villages <- append(modules_grid_three_villages, modules_grid)
  
  # calculating NMI
  nmi_observed <- fun_nmi_calc(modules_observed, TRUE)
  # saving results in one list
  nmi_observed_three_villages <- append(nmi_observed_three_villages, nmi_observed)
  
  ##### NMI for different values of core microbiome
  # calling the function
  nmi_diff_core <- fun_modularity_diff_core(data_asv_village, nmi_observed, core_seq) %>% 
    mutate(village = v)
  # saving results in one list
  nmi_diff_core_three_villages <- rbind(nmi_diff_core_three_villages, nmi_diff_core) 
  
  ##### phylogenetic analysis
  # ASVs pool
asv_pool <- data_asv_village %>% 
  distinct(asv_ID, asv_degree) %>% 
  mutate(p = asv_degree/length(unique(data_asv_village$asv_ID)))

# calculating betaNTI
data_betaNTI <- data_asv_village %>% 
  distinct(host_ID, asv_ID) %>% 
  mutate(reads = 1) %>% 
  spread(asv_ID, reads, fill = 0) %>% 
  column_to_rownames("host_ID") %>% 
  as.matrix()

betaNTI <- fun_calc_betaNTI(data_betaNTI, asv_distance, asv_pool) %>% 
  left_join(modules_observed %>% distinct(host_ID, host_group, grid), by=c("host1"="host_ID")) %>% rename(host_group1=host_group, grid1=grid) %>% 
  left_join(modules_observed %>% distinct(host_ID, host_group, grid), by=c("host2"="host_ID")) %>% rename(host_group2=host_group, grid2=grid) %>% 
  mutate(village = v)
betaNTI_three_villages <- rbind(betaNTI_three_villages, betaNTI)

# raup-crick
raupc <- raupcrick(data_betaNTI)
raupc2 <- as.matrix(raupc) 
raupc2[upper.tri(raupc2)] <- NA
diag(raupc2) <- NA
raupc2_m <- melt(raupc2) %>% 
  filter(!(is.na(value)))%>% 
  rename(host1 = Var1, host2 = Var2, raupc = value) %>% 
  left_join(modules_observed %>% distinct(host_ID, host_group, grid), by=c("host1"="host_ID")) %>% rename(host_group1=host_group, grid1=grid) %>% 
  left_join(modules_observed %>% distinct(host_ID, host_group, grid), by=c("host2"="host_ID")) %>% rename(host_group2=host_group, grid2=grid) %>% 
  mutate(village = v)
raupc_three_villages <- rbind(raupc_three_villages, raupc2_m)
}
```


# Network exploration {.tabset}


```{r, network_exploration}
# loop for three villages
for (i in 1:3) {
  
  cat('##',village_names[i],'{.tabset}','\n','\n')
  
  cat('### ASVs degree distribution','\n')
  
  print(asv_degree_distribution_three_villages[[i]])
  cat('\n','\n')
  
  # calculating connectance
  connectance_data <- modules_table_three_villages %>% 
    filter(village == village_names[i])
  
  cat('No. of hosts: ', length(unique(connectance_data$host_ID)) ,'\n','\n')
  cat('No. of ASVs: ', length(unique(connectance_data$asv_ID)) ,'\n','\n')
  cat('Connectance: ', nrow(connectance_data) / (length(unique(connectance_data$host_ID)) * length(unique(connectance_data$asv_ID))) ,'\n','\n')
  
  
  cat('### Modules','\n')
  cat('The color indicates number of host individuals in the module / total number of hosts in the whole grid [%]','\n','\n')
  
  print(modules_three_villages[[i]])
  cat('\n','\n')
  
  cat('### Modules size','\n')
  print(modules_size_three_villages[[i]])
  cat('\n','\n')
  
  cat('### No. of land uses','\n')
  print(modules_grid_three_villages[[i]])
  cat('\n','\n')
  
}

```

# Phylogenetic analysis {.tabset}

```{r, phylogenetic_analysis}
  cat('##', 'betaNTI','\n','\n')
  
  # same module?
  betaNTI_final <- betaNTI_three_villages %>% 
    mutate(same_module = ifelse(host_group1==host_group2, "Same","Different")) %>% 
    mutate(host_group1_org = host_group1) %>% 
  rowwise() %>%
  mutate(host_group1 = sort(c(host_group1, host_group2))[1], host_group2 = sort(c(host_group1_org, host_group2))[2])
    
  betaNTI_summary <- betaNTI_final %>% 
    group_by(village, same_module, host_group1, host_group2) %>% 
    summarise(mean_betaNTI = mean(betaNTI)) %>%
    group_by(village, same_module) %>% 
    summarise(betaNTI = mean(mean_betaNTI))
    print(knitr::kable(betaNTI_summary))
    cat('\n')
    
  #plotting
  betaNTI_g <- betaNTI_final %>% 
    group_by(village, same_module, host_group1, host_group2) %>% 
    summarise(mean_betaNTI = mean(betaNTI)) %>% 
  ggplot(aes(x=same_module, y=mean_betaNTI, fill=village)) + 
  geom_boxplot(outlier.shape = NA) + 
  geom_hline(yintercept = 0, linetype = "dashed") +
  theme_bw() +
  scale_y_continuous(limits = c(-2, 4), breaks = seq(-2,4, by=2)) +
  theme(axis.text = element_text(size = 14, color = 'black'), title = element_text(size = 20), panel.grid = element_blank()) +
    scale_fill_manual(values=group.colors) +
  labs(x="", y="betaNTI")
  print(betaNTI_g)
cat('\n','\n')
  

cat('##', 'Raup-Crick','\n','\n')
  
  # same module?
  raupc_final <- raupc_three_villages %>% 
    mutate(same_module = ifelse(host_group1==host_group2, "Same","Different")) %>% 
    mutate(host_group1_org = host_group1) %>% 
  rowwise() %>%
  mutate(host_group1 = sort(c(host_group1, host_group2))[1], host_group2 = sort(c(host_group1_org, host_group2))[2])
  
  raupc_summary <- raupc_final %>% 
    group_by(village, same_module, host_group1, host_group2) %>% 
    summarise(mean_raupc = mean(raupc)) %>%
    group_by(village, same_module) %>% 
    summarise(raupc = mean(mean_raupc))
    print(knitr::kable(raupc_summary))
    cat('\n')
    
  #plotting
  raupc_g <- raupc_final %>% 
    group_by(village, same_module, host_group1, host_group2) %>% 
    summarise(mean_raupc = mean(raupc)) %>% 
  ggplot(aes(x=same_module, y=mean_raupc, fill=village)) + 
  geom_boxplot(outlier.shape = NA) + 
  theme_bw() +
  scale_y_continuous(limits = c(0, 1), breaks = seq(0,1, by=0.2)) +
  theme(axis.text = element_text(size = 14, color = 'black'), title = element_text(size = 20), panel.grid = element_blank()) +
    scale_fill_manual(values=group.colors) +
  labs(x="", y="Raup-Crick")
  print(raupc_g)
cat('\n','\n')

```


# Normalized Mutual Information (NMI) {.tabset}

```{r, nmi}
cat('## NMI for common microbes','\n')
group.colors <- c(Andatsakala = "#e76f51", Mandena = "#2b9348", Sarahandrano = "#0077b6")
p1 <- nmi_diff_core_three_villages %>% 
  filter(type == "core") %>% 
  mutate(nmi = ifelse(is.na(nmi),0,nmi)) %>% 
  ggplot(aes(x=degree, y=nmi, color = village)) + 
  #geom_hline(yintercept = nmi_observed[[1]]$nmi, linetype = "dashed") +
  geom_line() +
  geom_point(aes(shape = as.factor(sig), size = n_module)) +
  scale_shape_manual(values = c(1, 16)) +
  scale_y_continuous(limits = c(0, 0.35)) +
  scale_x_continuous(limits = c(0, 20)) +
  theme_bw() +
  theme(axis.text = element_text(size = 12, color = 'black'), title = element_text(size = 15), panel.grid = element_blank()) +
  scale_color_manual(values=group.colors) +
  labs(x="Minimum ASVs Degree", y="Normalized Mutual Information (NMI)")
print(p1)
cat('\n','\n')

# loop for three villages
for (j in 1:3) {
  
  cat('##',village_names[j],'{.tabset}','\n','\n')
  
  print(nmi_observed_three_villages[[j*2]])
  cat('\n','\n')
}

```

# Modules similarity across land use change gradient


## Correlations between variables {.tabset}

Distance is a proxy for habitat degradation.

```{r, variables_correlation}
# reading grid similarity results
grids_similarity_attr <- read_csv("../data/data_processed/village_summary.csv")

# correlations between variables
# loop for three villages
library(psych)
for (j in village_names) {
  
  cat('###',j,'\n','\n')
  print(psych::pairs.panels(grids_similarity_attr %>% filter(village == j) %>%  select(-village,-grid1,-grid2), ellipses = F, lm = T))
  cat('\n','\n')
}
```



## Mantel test {.tabset}

```{r, mantel_test}
# mantel test for: modules similarity ~ distance between grids

# distance between grids matrices
load("../data/data_processed/distance_three_villages.RData")

# loop for three villages
for (i in 1:3) {
  
  cat('###',village_names[i],'{.tabset}','\n','\n')
  
  modules_similarity <- modules_similarity_three_villages[[i]]
  grid_names <- rownames(modules_similarity)
  grid_distance <- grid_distance_three_villages[[i]]
  # filtering the distance matrix to the existing grids
  grid_distance <- grid_distance[grid_names, grid_names]

  # calculating mantel test
  mantel_result <- vegan::mantel(modules_similarity, grid_distance)
  cat('r = ', mantel_result$statistic,'\n','\n')
  cat('p-value = ', 1-mantel_result$signif,'\n','\n')
  
  # transforming to long format
  modules_similarity_m <- modules_similarity
  modules_similarity_m[lower.tri(modules_similarity_m)] <- NA
  diag(modules_similarity_m) <- NA
  final_data <- melt(modules_similarity_m) %>% 
  filter(!is.na(value)) %>% 
  dplyr::rename(grid1 = Var2, grid2 = Var1, module_similarity = value) %>% 
    left_join(grids_similarity_attr %>% filter(village == village_names[i]), by=c("grid1","grid2"))
  
  # plotting
    g <- final_data %>% 
      ggplot(aes(y=module_similarity, x=grid_dist)) +
  geom_point(alpha = 0.8) +
  geom_smooth(method = "glm", se=T, method.args = list(family = "gaussian")) +
  theme_bw() +
  theme(axis.text = element_text(size = 10, color = 'black'), title = element_text(size = 14), strip.text.x = element_text(size=12),
        panel.grid.major = element_blank(),
          panel.grid.minor = element_blank()) +
  labs(x = "Distance Between Land Uses [m]", y = "Modules Similarity [Bray-Curtis]")
    print(g)
  cat('\n','\n')
}
```

# Link prediction {.tabset}

```{r}
library(caret)
library(yardstick)

# reading the ML results files
test_set <- read_csv("../data/data_processed/ML/test_set.csv")
feature_importance <- read_csv("../data/data_processed/ML/feature_importance.csv")

# setting a threshold for prediction
th <- 0.5
test_set_predict <- test_set %>% 
  select(y_true, y_proba) %>% 
  mutate(y_proba_th = ifelse(y_proba >= th, 1, 0)) %>% 
  mutate(predict = ifelse(y_true == y_proba_th, 1, 0)) %>% 
  mutate(y_proba_th = factor(y_proba_th, levels = c(1,0)), y_true = factor(y_true, levels = c(1,0)))

cat('## Metrics','\n','\n')

conf_matrix <- caret::confusionMatrix(data=test_set_predict$y_proba_th, reference = test_set_predict$y_true, dnn = c("Prediction", "Reference"))
print(knitr::kable(conf_matrix$table))
cat('\n','\n')

accuracy <- conf_matrix$overall['Accuracy']
cat("Accuracy: ", round(accuracy, 4), '\n')
precision <- conf_matrix$byClass['Precision']
cat("Precision: ", round(precision, 4), '\n')
recall <- conf_matrix$byClass['Sensitivity']
cat("Recall: ", round(recall, 4), '\n')
f1_score <- 2 * (precision * recall) / (precision + recall)
cat("F1_score: ", round(f1_score, 4), '\n','\n')

cat('## ROC curve','\n','\n')

auc_roc_score <- yardstick::roc_auc(test_set_predict, y_true, y_proba)
roc_obj <- yardstick::roc_curve(test_set_predict, y_true, y_proba) %>% 
ggplot(aes(x = 1 - specificity, y = sensitivity)) +
  geom_path(color = "blue") +
  geom_abline(lty = 3) +
  coord_equal() +
  theme_bw() +
  theme(plot.title = element_text(hjust = 0.5), plot.subtitle = element_text(hjust = 0.5))+
  labs(title = "ROC Curve", subtitle = paste("AUC = ", round(auc_roc_score$.estimate,3)))
print(roc_obj)
cat('\n','\n')

cat('## Precision-Recall curve','\n','\n')

auc_pr_score <- yardstick::pr_auc(test_set_predict, y_true, y_proba)
pr_obj <- yardstick::pr_curve(test_set_predict, y_true, y_proba) %>% 
ggplot(aes(x = recall, y = precision)) +
  geom_path(color = "blue") +
  coord_equal() +
  theme_bw() +
  theme(plot.title = element_text(hjust = 0.5), plot.subtitle = element_text(hjust = 0.5))+
  labs(title = "Precision-Recall curve", subtitle = paste("AUC = ", round(auc_pr_score$.estimate,3)))
print(pr_obj)
cat('\n','\n')

cat('## Features importance','\n','\n')

feature_imp_g <- feature_importance %>% 
  arrange(value) %>% 
    mutate(feature = factor(feature, levels = feature)) %>% 
    ggplot(aes(x=feature, y=value)) +
    geom_bar(stat = "identity") +
  coord_flip()+
    theme_bw() +
    theme(axis.text = element_text(size = 14, color = 'black'), title = element_text(size = 20), 
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank()) +
    labs(x="", y="Importance")
print(feature_imp_g)
cat('\n','\n')
```




