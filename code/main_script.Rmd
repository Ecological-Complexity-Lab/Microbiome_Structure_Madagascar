---
title: "Land use and microbe prevalence jointly determine host-microbe network structure"
subtitle: "Analysis and results"
author: "Matan Markfeld"
date: "Last edit: 2024-04-12"
output: 
  html_document:
    toc: true
    toc_float: true
    collapse: false
    number_sections: true
    code_folding: hide
    highlight: tango
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(results = "asis", message=FALSE, warning=FALSE, cache=TRUE, eval = TRUE, dev = c('png'), out.width = '100%', out.height='40%')
```


```{r load libraries, echo=FALSE, message=FALSE, warning=FALSE}
library(tidyverse)
library(magrittr)
library(ggplot2)
library(vegan)
library(igraph)
library(reshape2)
library(infomapecology)
library(aricode)
library(ape)
library(picante)

rm(list=ls())
```

```{r}
source("modularity_analysis_functions.R", local = knitr::knit_global())
```

```{r, microbiome data}
# reading the microbiome data
# working only with Rattus from the three villages
# removing the 'village' grid from the analysis

data_asv <- read_csv("../data/data_processed/microbiome/data_asv_rra0.01_th1000.csv") %>% 
  filter(host_species == "Rattus rattus")
```

```{r, main analysis, include=FALSE, results='hide'}
# first of all, run this chunk of code.
# this code does all the modularity analysis using the functions in "modularity_analysis_functions".
# There is a loop runs for the three villages, and all the analysis is done separately for each village.
# the output of the code is variables holding the final results tables and figures (the output of the functions used)

# setting thresholds for core
core_seq <- seq(1,1, by=1)

village_names <- unique(data_asv$village)
nmi_observed_three_villages <- NULL
nmi_diff_core_three_villages <- NULL
modules_similarity_three_villages <- NULL
asv_degree_distribution_three_villages <- NULL
modules_three_villages <- NULL
modules_size_three_villages <- NULL
modules_grid_three_villages <- NULL
modules_table_three_villages <- NULL
betaNTI_three_villages <- NULL
raupc_three_villages <- NULL

# reading the phylogenetic tree
best_tree <- readRDS(file = "../results/phylo_tree_0.01_2.rds")
phylo_tree <- best_tree$tree
# ASVs phylogenetic distance
asv_distance <- ape::cophenetic.phylo(phylo_tree)

# for loop for three villages
for (v in village_names) {
  
  data_asv_village <- data_asv %>% 
    filter(village == v)
  
  # calculating ASVs degree 
  asv_degree <- data_asv_village %>% 
    group_by(asv_ID) %>% 
    summarise(n = n_distinct(host_ID)) %>% 
    rename(asv_degree = n)
  data_asv_village %<>% left_join(asv_degree, by="asv_ID")
  
  ##### observed network
  # finding modules
  modules_observed <- fun_modularity_analysis(data_asv_village)
  modules_table_three_villages <- rbind(modules_table_three_villages, modules_observed)
  
  # calculating similarity in modules between grids
  modules_similarity <- fun_modules_similarity(modules_observed)
  # saving results in one table
  modules_similarity_three_villages <- append(modules_similarity_three_villages, modules_similarity)
  
  # ASVs degree distribution
  asv_degree_distribution <- fun_asv_degree_distribution(data_asv_village)
  asv_degree_distribution_three_villages <- append(asv_degree_distribution_three_villages, asv_degree_distribution)
  
  # figure of modules 
  modules <- fun_modules(modules_observed)
  modules_three_villages <- append(modules_three_villages, modules)
  
  # modules size
  modules_size <- fun_module_size(modules_observed)
  modules_size_three_villages <- append(modules_size_three_villages, modules_size)
  
  # Number of land uses per module
  modules_grid <- fun_module_grid(modules_observed)
  modules_grid_three_villages <- append(modules_grid_three_villages, modules_grid)
  
  # calculating NMI
  nmi_observed <- fun_nmi_calc(modules_observed, TRUE)
  # saving results in one list
  nmi_observed_three_villages <- append(nmi_observed_three_villages, nmi_observed)
  
  ##### NMI for different values of core microbiome
  # calling the function
  nmi_diff_core <- fun_modularity_diff_core(data_asv_village, nmi_observed, core_seq)
  # saving results in one list
  nmi_diff_core_three_villages <- append(nmi_diff_core_three_villages, nmi_diff_core)
  
  ##### phylogenetic analysis
  # ASVs pool
asv_pool <- data_asv_village %>% 
  distinct(asv_ID, asv_degree) %>% 
  mutate(p = asv_degree/length(unique(data_asv_village$asv_ID)))

# calculating betaNTI
data_betaNTI <- data_asv_village %>% 
  distinct(host_ID, asv_ID) %>% 
  mutate(reads = 1) %>% 
  spread(asv_ID, reads, fill = 0) %>% 
  column_to_rownames("host_ID") %>% 
  as.matrix()

betaNTI <- fun_calc_betaNTI(data_betaNTI, asv_distance, asv_pool) %>% 
  left_join(modules_observed %>% distinct(host_ID, host_group, grid), by=c("host1"="host_ID")) %>% rename(host_group1=host_group, grid1=grid) %>% 
  left_join(modules_observed %>% distinct(host_ID, host_group, grid), by=c("host2"="host_ID")) %>% rename(host_group2=host_group, grid2=grid) %>% 
  mutate(village = v)
betaNTI_three_villages <- rbind(betaNTI_three_villages, betaNTI)

# raup-crick
raupc <- raupcrick(data_betaNTI)
raupc2 <- as.matrix(raupc) 
raupc2[upper.tri(raupc2)] <- NA
diag(raupc2) <- NA
raupc2_m <- melt(raupc2) %>% 
  filter(!(is.na(value)))%>% 
  rename(host1 = Var1, host2 = Var2, raupc = value) %>% 
  left_join(modules_observed %>% distinct(host_ID, host_group, grid), by=c("host1"="host_ID")) %>% rename(host_group1=host_group, grid1=grid) %>% 
  left_join(modules_observed %>% distinct(host_ID, host_group, grid), by=c("host2"="host_ID")) %>% rename(host_group2=host_group, grid2=grid) %>% 
  mutate(village = v)
raupc_three_villages <- rbind(raupc_three_villages, raupc2_m)
}
```

# Modularity analysis

## Network exploration {.tabset}


```{r, network_exploration}
# loop for three villages
for (i in 1:3) {
  
  cat('###',village_names[i],'{.tabset}','\n','\n')
  
  cat('#### ASVs degree distribution','\n')
  
  print(asv_degree_distribution_three_villages[[i]])
  cat('\n','\n')
  
  # calculating connectance
  connectance_data <- modules_table_three_villages %>% 
    filter(village == village_names[i])
  
  cat('No. of hosts: ', length(unique(connectance_data$host_ID)) ,'\n','\n')
  cat('No. of ASVs: ', length(unique(connectance_data$asv_ID)) ,'\n','\n')
  cat('Connectance: ', nrow(connectance_data) / (length(unique(connectance_data$host_ID)) * length(unique(connectance_data$asv_ID))) ,'\n','\n')
  
  
  cat('#### Modules','\n')
  cat('The color indicates number of host individuals in the module / total number of hosts in the whole grid [%]','\n','\n')
  
  print(modules_three_villages[[i]])
  cat('\n','\n')
  
  cat('#### Modules size','\n')
  print(modules_size_three_villages[[i]])
  cat('\n','\n')
  
  cat('#### No. of land uses','\n')
  print(modules_grid_three_villages[[i]])
  cat('\n','\n')
  
}

```

# Phylogenetic analysis {.tabset}

```{r, phylogenetic_analysis}
  cat('##', 'betaNTI','\n','\n')
  
  # same module?
  betaNTI_final <- betaNTI_three_villages %>% 
    mutate(same_module = ifelse(host_group1==host_group2, "Same","Different")) %>% 
    mutate(host_group1_org = host_group1) %>% 
  rowwise() %>%
  mutate(host_group1 = sort(c(host_group1, host_group2))[1], host_group2 = sort(c(host_group1_org, host_group2))[2])
    
  #plotting
  betaNTI_g <- betaNTI_final %>% 
    group_by(village, same_module, host_group1, host_group2) %>% 
    summarise(mean_betaNTI = mean(betaNTI)) %>% 
  ggplot(aes(x=same_module, y=mean_betaNTI, fill=village)) + 
  geom_boxplot(outlier.shape = NA) + 
  theme_bw() +
  scale_y_continuous(limits = c(-2, 4), breaks = seq(-2,4, by=2)) +
  theme(axis.text = element_text(size = 8, color = 'black'), title = element_text(size = 20)) +
  labs(x="", y="betaNTI")
  print(betaNTI_g)
cat('\n','\n')
  

cat('##', 'Raup-Crick','\n','\n')
  
  # same module?
  raupc_final <- raupc_three_villages %>% 
    mutate(same_module = ifelse(host_group1==host_group2, "Same","Different")) %>% 
    mutate(host_group1_org = host_group1) %>% 
  rowwise() %>%
  mutate(host_group1 = sort(c(host_group1, host_group2))[1], host_group2 = sort(c(host_group1_org, host_group2))[2])
    
  #plotting
  raupc_g <- raupc_final %>% 
    group_by(village, same_module, host_group1, host_group2) %>% 
    summarise(mean_raupc = mean(raupc)) %>% 
  ggplot(aes(x=same_module, y=mean_raupc, fill=village)) + 
  geom_boxplot(outlier.shape = NA) + 
  theme_bw() +
  scale_y_continuous(limits = c(0, 1), breaks = seq(0,1, by=0.2)) +
  theme(axis.text = element_text(size = 8, color = 'black'), title = element_text(size = 20)) +
  labs(x="", y="Raup-Crick")
  print(raupc_g)
cat('\n','\n')

```


## Normalized Mutual Information (NMI) {.tabset}

```{r, nmi}
# loop for three villages
for (j in 1:3) {
  
  cat('###',village_names[j],'{.tabset}','\n','\n')
  
  cat('#### NMI','\n')
  print(nmi_observed_three_villages[[j*2]])
  cat('\n','\n')
  
  cat('#### NMI for common microbes','\n')
  print(nmi_diff_core_three_villages[[j]])
  cat('\n','\n')
}

```

# Modules similarity across land use change gradient

![image](../presentations/hypotheses.png)
I explore 4 non-mutual exclusive hypotheses for why land use affects the network's modular structure:

 1. **Random process**  - stochastic processes such as priority effect or just sampling error lead to random turnover of microbes and modules across grids. Therefore, no variable explains modules similarity.
 2. **environmental filtering** - grid attributes (vegetation) induce selective pressure. Therefore, grids with similar vegetation attributes have higher modules similarity.
 3. **Rattus movement** - Rattus individuals can move between grids. Therefore, closer grids have higher modules similarity.
 4. **Microbes reservoir** - microbes of other host species constitute a microbes reservoir in the grid. Therefore, grids with similart small mammals communities have higher modules similarity.



## Correlations between variables {.tabset}

Distance is a proxy for habitat degradation.

```{r, variables_correlation}
# reading grid similarity results
grids_similarity_attr <- read_csv("../data/data_processed/village_summary.csv")

# correlations between variables
# loop for three villages
library(psych)
for (j in village_names) {
  
  cat('###',j,'\n','\n')
  print(psych::pairs.panels(grids_similarity_attr %>% filter(village == j) %>%  select(-village,-grid1,-grid2), ellipses = F, lm = T))
  cat('\n','\n')
}
```



## Mantel test {.tabset}

```{r, mantel_test}
# mantel test for: modules similarity ~ distance between grids

# distance between grids matrices
load("../data/data_processed/distance_three_villages.RData")

# loop for three villages
for (i in 1:3) {
  
  cat('###',village_names[i],'{.tabset}','\n','\n')
  
  modules_similarity <- modules_similarity_three_villages[[i]]
  grid_names <- rownames(modules_similarity)
  grid_distance <- grid_distance_three_villages[[i]]
  # filtering the distance matrix to the existing grids
  grid_distance <- grid_distance[grid_names, grid_names]

  # calculating mantel test
  mantel_result <- vegan::mantel(modules_similarity, grid_distance)
  cat('r: ', mantel_result$statistic,'\n')
  cat('p-value: ', 1-mantel_result$signif,'\n')
  
  # transforming to long format
  modules_similarity_m <- modules_similarity
  modules_similarity_m[lower.tri(modules_similarity_m)] <- NA
  diag(modules_similarity_m) <- NA
  final_data <- melt(modules_similarity_m) %>% 
  filter(!is.na(value)) %>% 
  dplyr::rename(grid1 = Var2, grid2 = Var1, module_similarity = value) %>% 
    left_join(grids_similarity_attr %>% filter(village == village_names[i]), by=c("grid1","grid2"))
  
  # plotting
    g <- final_data %>% 
      ggplot(aes(y=module_similarity, x=sm_community)) +
  geom_point(alpha = 0.8) +
  geom_smooth(method = "glm", se=T, method.args = list(family = "gaussian")) +
  theme_bw() +
  theme(axis.text = element_text(size = 10, color = 'black'), title = element_text(size = 14), strip.text.x = element_text(size=12)) +
  labs(x = "Difference in Distance from Village [m]", y = "Modules Similarity [Bray-Curtis]")
    print(g)
  cat('\n','\n')
}
```





