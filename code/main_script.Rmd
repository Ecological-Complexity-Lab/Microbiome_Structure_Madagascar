---
title: "Land use and microbe prevalence jointly determine host-microbe network structure"
subtitle: "Analysis and results"
author: "Matan Markfeld"
date: "Last edit: 2024-05-23"
output: 
  html_document:
    toc: true
    toc_float: true
    collapse: false
    number_sections: true
    code_folding: hide
    highlight: tango
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(results = "asis", message=FALSE, warning=FALSE, cache=TRUE, eval = TRUE, dev = c('png'), out.width = '100%', out.height='60%')
```


```{r load libraries, echo=FALSE, message=FALSE, warning=FALSE}
library(tidyverse)
library(magrittr)
library(ggplot2)
library(vegan)
library(igraph)
library(reshape2)
library(infomapecology)
library(aricode)
library(ape)
library(picante)
library(patchwork)

rm(list=ls())
```

```{r}
source("modularity_analysis_functions.R", local = knitr::knit_global())
```

```{r, microbiome data}
# reading the microbiome data
# working only with Rattus from the three villages

data_asv <- read_csv("../data/data_processed/microbiome/data_asv_rra0.01_th1000_clean.csv") %>% 
  filter(host_species == "Rattus rattus" & grid!="village")

group.colors <- c(Andatsakala = "#e76f51", Mandena = "#2b9348", Sarahandrano = "#0077b6")
```

# Exploration {.tabset}

```{r, sm exploration}
# small mammals data
small_mammals <- read_csv("../data/data_raw/data_small_mammals/Terrestrial_Mammals.csv") %>% 
  mutate(host_ID = as.numeric(gsub(".*?([0-9]+).*", "\\1", animal_id))) %>% 
  mutate(age_repro = as_factor(age_repro)) %>% 
  rename(grid = habitat_type) %>% 
  filter(host_ID %in% data_asv$host_ID)

cat("## Abundance", '\n','\n')
g <- small_mammals %>% 
  count(village, grid) %>% 
  ggplot(aes(fill=village, x=grid, y=n)) +
  geom_bar(position="dodge", stat="identity") +
  theme_bw() +
  theme(axis.text = element_text(size = 10, color = 'black', angle = 90, vjust = 0.5, hjust=1), title = element_text(size = 14)) +
  scale_fill_manual(values=group.colors) +
  labs(x="Land Use", y="Small-Mammals Abundance")
print(g)

cat("## Sex ratio", '\n','\n')
g <- small_mammals %>% 
  count(village, grid, sex) %>% 
  ggplot(aes(fill=sex, x=grid, y=n)) +
  geom_bar(position="fill", stat="identity") +
  facet_wrap(~village) +
  geom_hline(yintercept = 0.5, linetype = "dashed") +
  theme_bw() +
  theme(axis.text = element_text(size = 10, color = 'black', angle = 90, vjust = 0.5, hjust=1), title = element_text(size = 14)) +
  labs(x="Land Use", y="Proportion")
print(g)

cat("## Age ratio", '\n','\n')
g <- small_mammals %>% 
  count(village, grid, age_repro) %>% 
  ggplot(aes(fill=age_repro, x=grid, y=n)) +
  geom_bar(position="fill", stat="identity") +
  facet_wrap(~village) +
  theme_bw() +
  theme(axis.text = element_text(size = 10, color = 'black', angle = 90, vjust = 0.5, hjust=1), title = element_text(size = 14)) +
  labs(x="Land Use", y="Proportion")
print(g)
```


```{r, microbiome exploration}
# microbes taxonomy
tax <- read_delim("../data/data_raw/data_microbiome/ASVs_taxonomy_new.tsv") %>% 
  dplyr::rename(asv_ID = ASV)

data_asv_tax <- data_asv %>% 
  left_join(tax, by="asv_ID")

cat("## Relative abundance", '\n','\n')
g <- data_asv_tax %>% 
  group_by(village, grid, Phylum) %>% 
  summarise(n= mean(reads)) %>% 
  ggplot(aes(fill=Phylum, x=grid, y=n)) +
  geom_bar(position="fill", stat="identity") +
  facet_wrap(~village) +
  theme_bw() +
  theme(axis.text = element_text(size = 10, color = 'black', angle = 90, vjust = 0.5, hjust=1), title = element_text(size = 14)) +
  labs(x="Land Use", y="Relative abundance")
print(g)

cat("## Rare", '\n','\n')
g <- data_asv_tax %>% 
  count(village, grid, asv_ID, Phylum) %>%
  filter(n < 2) %>% 
  group_by(village, grid, Phylum) %>% 
  summarise(n_asv= n_distinct(asv_ID)) %>% 
  ggplot(aes(fill=Phylum, x=grid, y=n_asv)) +
  geom_bar(position="fill", stat="identity") +
  facet_wrap(~village) +
  theme_bw() +
  theme(axis.text = element_text(size = 10, color = 'black', angle = 90, vjust = 0.5, hjust=1), title = element_text(size = 14)) +
  labs(x="Land Use", y="Proportion No. of ASVs")
print(g)

cat("## Common", '\n','\n')
g <- data_asv_tax %>% 
  count(village, grid, asv_ID, Genus) %>%
  filter(n > 9) %>% 
  group_by(village, grid, Genus) %>% 
  summarise(n_asv= n_distinct(asv_ID)) %>% 
  ggplot(aes(fill=Genus, x=grid, y=n_asv)) +
  geom_bar(position="fill", stat="identity") +
  facet_wrap(~village) +
  theme_bw() +
  theme(axis.text = element_text(size = 10, color = 'black', angle = 90, vjust = 0.5, hjust=1), title = element_text(size = 14)) +
  labs(x="Land Use", y="Proportion No. of ASVs")
print(g)
```

```{r, main analysis, include=FALSE, results='hide'}
# first of all, run this chunk of code.
# this code does all the modularity analysis using the functions in "modularity_analysis_functions".
# There is a loop runs for the three villages, and all the analysis is done separately for each village.
# the output of the code is variables holding the final results tables and figures (the output of the functions used)

# setting thresholds for core
core_seq <- seq(1,20, by=1)

village_names <- unique(data_asv$village)
nmi_observed_three_villages <- NULL
nmi_diff_core_three_villages <- NULL
modules_similarity_three_villages <- NULL
asv_degree_distribution_three_villages <- NULL
modules_three_villages <- NULL
modules_size_three_villages <- NULL
modules_grid_three_villages <- NULL
modules_table_three_villages <- NULL
betaNTI_three_villages <- NULL
raupc_three_villages <- NULL

# reading the phylogenetic tree
best_tree <- readRDS(file = "../results/phylo_tree_0.01_2.rds")
phylo_tree <- best_tree$tree
# ASVs phylogenetic distance
asv_distance <- ape::cophenetic.phylo(phylo_tree)

# for loop for three villages
for (v in village_names) {
  
  data_asv_village <- data_asv %>% 
    filter(village == v)
  
  # calculating ASVs degree 
  asv_degree <- data_asv_village %>% 
    group_by(asv_ID) %>% 
    summarise(n = n_distinct(host_ID)) %>% 
    rename(asv_degree = n)
  data_asv_village %<>% left_join(asv_degree, by="asv_ID")
  
  ##### observed network
  # finding modules
  modules_observed <- fun_modularity_analysis(data_asv_village)
  modules_table_three_villages <- rbind(modules_table_three_villages, modules_observed)
  #write_csv(modules_table_three_villages, "../results/modules_table_three_villages.csv")
  
  # calculating similarity in modules between grids
  modules_similarity <- fun_modules_similarity(modules_observed)
  # saving results in one table
  modules_similarity_three_villages <- append(modules_similarity_three_villages, modules_similarity)
  
  # ASVs degree distribution
  asv_degree_distribution <- fun_asv_degree_distribution(data_asv_village)
  asv_degree_distribution_three_villages <- append(asv_degree_distribution_three_villages, asv_degree_distribution)
  
  # figure of modules 
  modules <- fun_modules(modules_observed)
  modules_three_villages <- append(modules_three_villages, modules)
  
  # modules size
  modules_size <- fun_module_size(modules_observed)
  modules_size_three_villages <- append(modules_size_three_villages, modules_size)
  
  # Number of land uses per module
  modules_grid <- fun_module_grid(modules_observed)
  modules_grid_three_villages <- append(modules_grid_three_villages, modules_grid)
  
  # calculating NMI
  nmi_observed <- fun_nmi_calc(modules_observed, TRUE)
  # saving results in one list
  nmi_observed_three_villages <- append(nmi_observed_three_villages, nmi_observed)
  
  ##### NMI for different values of core microbiome
  # calling the function
  nmi_diff_core <- fun_modularity_diff_core(data_asv_village, nmi_observed, core_seq) %>% 
    mutate(village = v)
  # saving results in one list
  nmi_diff_core_three_villages <- rbind(nmi_diff_core_three_villages, nmi_diff_core) 
  
  ##### phylogenetic analysis
  # ASVs pool
asv_pool <- data_asv_village %>% 
  distinct(asv_ID, asv_degree) %>% 
  mutate(p = asv_degree/length(unique(data_asv_village$asv_ID)))

# calculating betaNTI
data_betaNTI <- data_asv_village %>% 
  distinct(host_ID, asv_ID) %>% 
  mutate(reads = 1) %>% 
  spread(asv_ID, reads, fill = 0) %>% 
  column_to_rownames("host_ID") %>% 
  as.matrix()

betaNTI <- fun_calc_betaNTI(data_betaNTI, asv_distance, asv_pool) %>% 
  left_join(modules_observed %>% distinct(host_ID, host_group, grid), by=c("host1"="host_ID")) %>% rename(host_group1=host_group, grid1=grid) %>% 
  left_join(modules_observed %>% distinct(host_ID, host_group, grid), by=c("host2"="host_ID")) %>% rename(host_group2=host_group, grid2=grid) %>% 
  mutate(village = v)
betaNTI_three_villages <- rbind(betaNTI_three_villages, betaNTI)

# raup-crick
raupc <- raupcrick(data_betaNTI)
raupc2 <- as.matrix(raupc) 
raupc2[upper.tri(raupc2)] <- NA
diag(raupc2) <- NA
raupc2_m <- melt(raupc2) %>% 
  filter(!(is.na(value)))%>% 
  rename(host1 = Var1, host2 = Var2, raupc = value) %>% 
  left_join(modules_observed %>% distinct(host_ID, host_group, grid), by=c("host1"="host_ID")) %>% rename(host_group1=host_group, grid1=grid) %>% 
  left_join(modules_observed %>% distinct(host_ID, host_group, grid), by=c("host2"="host_ID")) %>% rename(host_group2=host_group, grid2=grid) %>% 
  mutate(village = v)
raupc_three_villages <- rbind(raupc_three_villages, raupc2_m)
}
```


# Network exploration {.tabset}


```{r, network_exploration}
# loop for three villages
for (i in 1:3) {
  
  cat('##',village_names[i],'{.tabset}','\n','\n')
  
  cat('### ASVs degree distribution','\n')
  
  print(asv_degree_distribution_three_villages[[i]])
  cat('\n','\n')
  
  # calculating connectance
  connectance_data <- modules_table_three_villages %>% 
    filter(village == village_names[i])
  
  cat('No. of hosts: ', length(unique(connectance_data$host_ID)) ,'\n','\n')
  cat('No. of ASVs: ', length(unique(connectance_data$asv_ID)) ,'\n','\n')
  cat('Connectance: ', nrow(connectance_data) / (length(unique(connectance_data$host_ID)) * length(unique(connectance_data$asv_ID))) ,'\n','\n')
  
  
  cat('### Modules','\n')
  cat('The color indicates number of host individuals in the module / total number of hosts in the whole grid [%]','\n','\n')
  
  print(modules_three_villages[[i]])
  cat('\n','\n')
  
  cat('### Modules size','\n')
  print(modules_size_three_villages[[i]])
  cat('\n','\n')
  
  cat('### No. of land uses','\n')
  print(modules_grid_three_villages[[i]])
  cat('\n','\n')
  
}

```

# Phylogenetic analysis

```{r, phylogenetic_analysis, fig.width=12}
  
  # same module?
  betaNTI_final <- betaNTI_three_villages %>% 
    mutate(same_module = ifelse(host_group1==host_group2, "Same","Different")) %>% 
    mutate(host_group1_org = host_group1) %>% 
  rowwise() %>%
  mutate(host_group1 = sort(c(host_group1, host_group2))[1], host_group2 = sort(c(host_group1_org, host_group2))[2])
    
  betaNTI_summary <- betaNTI_final %>% 
    group_by(village, same_module, host_group1, host_group2) %>% 
    summarise(mean_betaNTI = mean(betaNTI)) %>%
    group_by(village, same_module) %>% 
    summarise(betaNTI = mean(mean_betaNTI))
    
  #plotting
  betaNTI_g <- betaNTI_final %>% 
    group_by(village, same_module, host_group1, host_group2) %>% 
    summarise(mean_betaNTI = mean(betaNTI)) %>% 
  ggplot(aes(x=same_module, y=mean_betaNTI, fill=village)) + 
  geom_boxplot(outlier.shape = NA, alpha=0.8) + 
  geom_label(data = betaNTI_summary, aes(label = sprintf("%.2f", betaNTI), y = betaNTI), position = position_dodge(width = 0.75), size = 4,color="white",alpha=0.8, show.legend=F) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  theme_bw() +
  scale_y_continuous(limits = c(-2, 4), breaks = seq(-2,4, by=2)) +
  theme(axis.text = element_text(size = 14, color = 'black'), title = element_text(size = 20), panel.grid = element_blank(), legend.position = "none") +
    scale_fill_manual(values=group.colors) +
  labs(x="", y=paste("\u03B2","NTI", sep = ""))
  
  
  # same module?
  raupc_final <- raupc_three_villages %>% 
    mutate(same_module = ifelse(host_group1==host_group2, "Same","Different")) %>% 
    mutate(host_group1_org = host_group1) %>% 
  rowwise() %>%
  mutate(host_group1 = sort(c(host_group1, host_group2))[1], host_group2 = sort(c(host_group1_org, host_group2))[2])
  
  raupc_summary <- raupc_final %>% 
    group_by(village, same_module, host_group1, host_group2) %>% 
    summarise(mean_raupc = mean(raupc)) %>%
    group_by(village, same_module) %>% 
    summarise(raupc = mean(mean_raupc))
    
    
  #plotting
  raupc_g <- raupc_final %>% 
    group_by(village, same_module, host_group1, host_group2) %>% 
    summarise(mean_raupc = mean(raupc)) %>% 
  ggplot(aes(x=same_module, y=mean_raupc, fill=village)) + 
  geom_boxplot(outlier.shape = NA, alpha=0.8) + 
  geom_label(data = raupc_summary, aes(label = sprintf("%.2f", raupc), y = raupc), position = position_dodge(width = 0.75), size = 4, color="white",alpha=0.8, show.legend=F) +
  theme_bw() +
  scale_y_continuous(limits = c(0, 1), breaks = seq(0,1, by=0.2)) +
  theme(axis.text = element_text(size = 14, color = 'black'), title = element_text(size = 20), panel.grid = element_blank()) +
    scale_fill_manual(values=group.colors) +
  labs(x="", y="Raup-Crick", fill="Village")
  

# plotting the final figure
p <- betaNTI_g + raupc_g
print(p)
cat('\n','\n')
```


# Normalized Mutual Information (NMI) {.tabset}

```{r, nmi, height=5}
cat('## Observed NMI','\n')

# making a data frame out of the shuffled results
# loop for three villages
nmi_observed_df_tv <- NULL
for (j in 1:3) {
  nmi_observed_df <- data_frame(nmi = nmi_observed_three_villages[[j*2]]) %>% 
  mutate(village = village_names[j])
  nmi_observed_df_tv <- rbind(nmi_observed_df_tv, nmi_observed_df)
}

# making a data frame out of the observed results
nmi_observed_three_villages_df <- nmi_observed_three_villages[[1]] %>% 
  bind_rows(nmi_observed_three_villages[[3]]) %>% 
  bind_rows(nmi_observed_three_villages[[5]]) %>% 
  mutate(village = village_names)

g <- nmi_observed_df_tv %>% 
      ggplot(aes(nmi, fill=village)) + 
      geom_histogram(alpha=0.8, color="white") + 
      facet_wrap(~village, scales="free") +
    scale_y_continuous(limits = c(0, 100)) +
  geom_vline(data=nmi_observed_three_villages_df, aes(xintercept = nmi), linetype='dashed', color="black") +
      geom_label(data = nmi_observed_three_villages_df, aes(label = paste("NMI =", round(nmi,2)), x = Inf, y = Inf),
            vjust = 1.5,hjust = 1.1, size = 4, color = "black", fill="white") +
      theme_bw() +
      
      theme(axis.text = element_text(size = 10, color = 'black'), title = element_text(size = 14), strip.text = element_text(size=12), panel.grid = element_blank(), legend.position="none") +
  scale_y_continuous(expand = expansion(mult = c(0.01, 0.01))) +
  scale_fill_manual(values=group.colors) +
      labs(x="Normalized Mutual Information (NMI)", y="Count")
print(g)
cat('\n','\n')



cat('## NMI for common microbes','\n')

nmi_observed_df <- nmi_diff_core_three_villages %>% 
  filter(type=="core", degree==1) %>% 
  arrange(village)

p1 <- nmi_diff_core_three_villages %>% 
  filter(type == "core") %>% 
  mutate(nmi = ifelse(is.na(nmi),0,nmi)) %>% 
  ggplot(aes(x=degree, y=nmi, color = village)) + 
  #geom_hline(yintercept=nmi_observed_df$nmi, linetype = "dashed", color=group.colors) +
  geom_line() +
  geom_point(aes(shape = as.factor(sig), size = n_module)) +
  scale_size_continuous( breaks = c(1,10,40,80)) +
  scale_shape_manual(values = c(1, 16), guide="none") +
  scale_y_continuous(limits = c(0, 0.35)) +
  scale_x_continuous(limits = c(0, 20)) +
  theme_bw() +
  theme(axis.text = element_text(size = 12, color = 'black'), title = element_text(size = 15), panel.grid = element_blank(), panel.border = element_rect(color = "black"), legend.position = c(.95, .95), legend.justification = c("right", "top"),  legend.title = element_text(size = 12)) +
  scale_color_manual(values=group.colors) +
  guides(size = guide_legend(order = 2), color = guide_legend(order = 1)) +
  labs(x="Minimum ASVs Degree", y="Normalized Mutual Information (NMI)", size = "No. of Modules", color = "Village")
print(p1)
#legend.position = c(.95, .95), legend.justification = c("right", "top"),
cat('\n','\n')

```

# Modules similarity across land use change gradient


## Correlations between variables {.tabset}

Distance is a proxy for habitat degradation.

```{r, variables_correlation}
# reading grid similarity results
grids_similarity_attr <- read_csv("../data/data_processed/village_summary.csv")

# correlations between variables
# loop for three villages
library(psych)
for (j in village_names) {
  
  cat('###',j,'\n','\n')
  print(psych::pairs.panels(grids_similarity_attr %>% filter(village == j) %>%  select(-village,-grid1,-grid2), ellipses = F, lm = T))
  cat('\n','\n')
}
```



## Mantel test

```{r, mantel_test}
# mantel test for: modules similarity ~ distance between grids

# distance between grids matrices
load("../data/data_processed/distance_three_villages.RData")

mantel_result_three_villages <- NULL
final_data_three_villages <- NULL

# loop for three villages
for (i in 1:3) {
  
  modules_similarity <- modules_similarity_three_villages[[i]]
  grid_names <- rownames(modules_similarity)
  grid_distance <- grid_distance_three_villages[[i]]
  # filtering the distance matrix to the existing grids
  grid_distance <- grid_distance[grid_names, grid_names]

  # calculating mantel test
  mantel_result <- vegan::mantel(modules_similarity, grid_distance)
  mantel_result_df <- data_frame(r = round(mantel_result$statistic,2),
                                 pvalue = round(1-mantel_result$signif,4),
                                 village = village_names[i])
  mantel_result_three_villages <- rbind(mantel_result_three_villages, mantel_result_df)
  
  
  # transforming to long format
  modules_similarity_m <- modules_similarity
  modules_similarity_m[lower.tri(modules_similarity_m)] <- NA
  diag(modules_similarity_m) <- NA
  final_data <- melt(modules_similarity_m) %>% 
  filter(!is.na(value)) %>% 
  dplyr::rename(grid1 = Var2, grid2 = Var1, module_similarity = value) %>% 
    left_join(grids_similarity_attr %>% filter(village == village_names[i]), by=c("grid1","grid2"))
  
  final_data_three_villages <- rbind(final_data_three_villages, final_data)
  
}

# plotting
    g <- final_data_three_villages %>% 
      ggplot(aes(y=module_similarity, x=grid_dist, color = village)) +
  geom_point(alpha = 0.8) +
  facet_wrap(~village, scales="free")+
  scale_y_continuous(limits = c(0.0, 0.6)) +
  geom_smooth(method = "glm", se=T, method.args = list(family = "gaussian")) +
  geom_text(data = mantel_result_three_villages, aes(label = paste("r =", r), x = Inf, y = Inf),
            hjust = 1.3, vjust = 1.5, size = 4, color = "black") +
      geom_text(data = mantel_result_three_villages, aes(label = paste("p-value =", pvalue), x = Inf, y = Inf),
            hjust = 1.1, vjust = 3, size = 4, color = "black") +
  theme_bw() +
  theme(axis.text = element_text(size = 10, color = 'black'), title = element_text(size = 14), strip.text.x = element_text(size=12),
        panel.grid = element_blank(), legend.position = "none", panel.border = element_rect(color = "black")) +
      scale_color_manual(values=group.colors) +
  labs(x = "Distance Between Land Uses [m]", y = "Modules Similarity [Bray-Curtis]")
    print(g)
  cat('\n','\n')
```

# Link prediction {.tabset}

```{r}
library(caret)
library(yardstick)

# reading the ML results files
test_set <- read_csv("link_prediction/test_set.csv")
feature_importance <- read_csv("link_prediction/feature_importance.csv")

# setting a threshold for prediction
th <- 0.5
test_set_predict <- test_set %>% 
  select(y_true, y_proba) %>% 
  mutate(y_proba_th = ifelse(y_proba >= th, 1, 0)) %>% 
  mutate(predict = ifelse(y_true == y_proba_th, 1, 0)) %>% 
  mutate(y_proba_th = factor(y_proba_th, levels = c(1,0)), y_true = factor(y_true, levels = c(1,0)))

cat('## Metrics','\n','\n')

conf_matrix <- caret::confusionMatrix(data=test_set_predict$y_proba_th, reference = test_set_predict$y_true, dnn = c("Prediction", "Reference"))
print(knitr::kable(conf_matrix$table))
cat('\n','\n')

accuracy <- conf_matrix$overall['Accuracy']
cat("Accuracy: ", round(accuracy, 4), '\n')
precision <- conf_matrix$byClass['Precision']
cat("Precision: ", round(precision, 4), '\n')
recall <- conf_matrix$byClass['Sensitivity']
cat("Recall: ", round(recall, 4), '\n')
f1_score <- 2 * (precision * recall) / (precision + recall)
cat("F1_score: ", round(f1_score, 4), '\n','\n')

cat('## ROC curve','\n','\n')

auc_roc_score <- yardstick::roc_auc(test_set_predict, y_true, y_proba)
roc_obj <- yardstick::roc_curve(test_set_predict, y_true, y_proba) %>% 
ggplot(aes(x = 1 - specificity, y = sensitivity)) +
  geom_path(color = "blue") +
  geom_abline(lty = 3) +
  coord_equal() +
  theme_bw() +
  theme(plot.title = element_text(hjust = 0.5), plot.subtitle = element_text(hjust = 0.5))+
  labs(title = "ROC Curve", subtitle = paste("AUC = ", round(auc_roc_score$.estimate,3)))
print(roc_obj)
cat('\n','\n')

cat('## Precision-Recall curve','\n','\n')

auc_pr_score <- yardstick::pr_auc(test_set_predict, y_true, y_proba)
pr_obj <- yardstick::pr_curve(test_set_predict, y_true, y_proba) %>% 
ggplot(aes(x = recall, y = precision)) +
  geom_path(color = "blue") +
  coord_equal() +
  theme_bw() +
  theme(plot.title = element_text(hjust = 0.5), plot.subtitle = element_text(hjust = 0.5))+
  labs(title = "Precision-Recall curve", subtitle = paste("AUC = ", round(auc_pr_score$.estimate,3)))
print(pr_obj)
cat('\n','\n')

cat('## Features importance','\n','\n')

feature_imp_g <- feature_importance %>% 
  arrange(value) %>% 
    mutate(feature = factor(feature, levels = feature)) %>% 
    ggplot(aes(x=feature, y=value)) +
    geom_bar(stat = "identity") +
  coord_flip()+
  scale_y_continuous(limits = c(0, 1)) +
    theme_bw() +
    theme(axis.text = element_text(size = 14, color = 'black'), title = element_text(size = 20), 
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank()) +
    labs(x="", y="Importance")
print(feature_imp_g)
cat('\n','\n')
```




